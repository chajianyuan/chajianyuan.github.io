<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>查见原的博客</title>
  
  <subtitle>越努力，越幸运</subtitle>
  <link href="http://chajianyuanblog.com/atom.xml" rel="self"/>
  
  <link href="http://chajianyuanblog.com/"/>
  <updated>2020-03-27T00:51:20.000Z</updated>
  <id>http://chajianyuanblog.com/</id>
  
  <author>
    <name>chajianyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue：vue版本之间的区别</title>
    <link href="http://chajianyuanblog.com/2020/03/27/vue%EF%BC%9Avue%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://chajianyuanblog.com/2020/03/27/vue%EF%BC%9Avue%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-27T00:51:17.000Z</published>
    <updated>2020-03-27T00:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/80/v2-120c6f2e62e740210a77ab3c87d65c0e_1440w.jpg"></p><ul><li><p>运行时版本 vue.runtime.js</p><ul><li><p>不支持从 html 获取视图；</p></li><li><p>不支持 template，需要通过 webpack 的工具 vue-loader 将组件，预编译 template 模板为 render 函数；</p></li><li><p>没有 complier 编译器，因此代码体积会比完整版小 40%，html 转化成节点。</p><p><code>&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.9/vue.runtime.min.js&quot;&gt;&lt;/script&gt;</code></p></li></ul></li><li><p>完整版 vue.js</p><ul><li>支持从 html 获取视图；</li><li>支持 template；</li><li>有 complier 编译器，而 complier 可以将字符串<br><code>&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-120c6f2e62e740210a77ab3c87d65c0e_1440w.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运行时版本 vue.runtime.js&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="vue" scheme="http://chajianyuanblog.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Node：学习koa.js</title>
    <link href="http://chajianyuanblog.com/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0koa.js/"/>
    <id>http://chajianyuanblog.com/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0koa.js/</id>
    <published>2020-03-26T01:01:10.000Z</published>
    <updated>2020-03-26T01:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、优缺点"><a href="#一、优缺点" class="headerlink" title="一、优缺点"></a>一、优缺点</h2><ul><li><strong>优点：</strong>no callback</li><li><strong>缺点：</strong>content/express 的中间件基本不能重用，基本要重写；依然需要更多人的支持和学习。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、优缺点&quot;&gt;&lt;a href=&quot;#一、优缺点&quot; class=&quot;headerlink&quot; title=&quot;一、优缺点&quot;&gt;&lt;/a&gt;一、优缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;no callback&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="koa" scheme="http://chajianyuanblog.com/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Node：学习Express.js</title>
    <link href="http://chajianyuanblog.com/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0Express.js/"/>
    <id>http://chajianyuanblog.com/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0Express.js/</id>
    <published>2020-03-26T00:50:44.000Z</published>
    <updated>2020-03-26T00:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、优缺点"><a href="#一、优缺点" class="headerlink" title="一、优缺点"></a>一、优缺点</h2><ul><li><strong>优点：</strong>历史悠久，文档更完整，资料更多，深入人心；</li><li><strong>缺点：</strong>不能忍的 callback</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、优缺点&quot;&gt;&lt;a href=&quot;#一、优缺点&quot; class=&quot;headerlink&quot; title=&quot;一、优缺点&quot;&gt;&lt;/a&gt;一、优缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;历史悠久，文档更完整，资料更多，深入人心；&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="node" scheme="http://chajianyuanblog.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>总结：Node.js</title>
    <link href="http://chajianyuanblog.com/2020/03/26/%E6%80%BB%E7%BB%93%EF%BC%9ANode.js/"/>
    <id>http://chajianyuanblog.com/2020/03/26/%E6%80%BB%E7%BB%93%EF%BC%9ANode.js/</id>
    <published>2020-03-26T00:45:13.000Z</published>
    <updated>2020-03-26T00:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Express-js"><a href="#1、Express-js" class="headerlink" title="1、Express.js"></a>1、Express.js</h2><p><a href="">参见总结：Node：学习 Express.js</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、Express-js&quot;&gt;&lt;a href=&quot;#1、Express-js&quot; class=&quot;headerlink&quot; title=&quot;1、Express.js&quot;&gt;&lt;/a&gt;1、Express.js&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;参见总结：Node：学习 Expres</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>网络协议：http和https</title>
    <link href="http://chajianyuanblog.com/2020/03/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Ahttp%E5%92%8Chttps/"/>
    <id>http://chajianyuanblog.com/2020/03/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Ahttp%E5%92%8Chttps/</id>
    <published>2020-03-25T00:39:45.000Z</published>
    <updated>2020-03-25T01:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、http"><a href="#一、http" class="headerlink" title="一、http"></a>一、http</h2><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ef70cbdc63e95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>HTTP 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，适用于从万维网服务器传输文本到本地浏览器的传送协议。</p><h3 id="1、http-1-1-的缺陷"><a href="#1、http-1-1-的缺陷" class="headerlink" title="1、http/1.1 的缺陷"></a>1、http/1.1 的缺陷</h3><ul><li>高延迟–带来页面加载速度的降低；</li><li>无状态特性–带来的巨大 HTTP 头部；</li><li>明文传输–带来的不安全性；</li><li>不支持服务器推送消息。</li></ul><h3 id="2、http-2"><a href="#2、http-2" class="headerlink" title="2、http/2"></a>2、http/2</h3><p><strong>新特性：</strong></p><ul><li>二进制传输；</li><li>Header 压缩；</li><li>多路复用；</li><li>Server Push；</li><li>提高安全性</li></ul><p><strong>缺陷：</strong></p><ul><li>TCP 以及 TCP+TLS 建立连接的延时；</li><li>TCP 的队头阻塞并没有彻底解决。</li></ul><h3 id="3、HTTP-3"><a href="#3、HTTP-3" class="headerlink" title="3、HTTP/3"></a>3、HTTP/3</h3><p><strong>QUIC</strong>是基于 UDP 的一个协议，让 http 跑在 QUIC 上而不是 TCP 上。而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本–HTTP/3。</p><h4 id="QUIC-新功能"><a href="#QUIC-新功能" class="headerlink" title="QUIC 新功能"></a>QUIC 新功能</h4><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能；</li><li>实现了快速握手功；</li><li>集成了 TLS 加密功能；</li><li>多路复用，彻底解决 TCP 中队头阻塞的问题。</li></ul><h2 id="二、HTTPS"><a href="#二、HTTPS" class="headerlink" title="二、HTTPS"></a>二、HTTPS</h2><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。</p><p><strong>HTTP 和 HTTPS 的区别：</strong></p><ul><li>HTTP 是明文传输，HTTPS 通过 SSL/TLS 进行了加密；</li><li>HTTP 的端口号是 80，HTTPS 的是 443；</li><li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费；</li><li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><p><a href="https://juejin.im/post/5b1e93aa5188257d3914280e">掘金：关于 http 协议，你必须要知道的</a></p><p><a href="https://juejin.im/post/5d9abde7e51d4578110dc77f">掘金：解密 http/2 与 http/3 的新特性</a></p><p><a href="https://juejin.im/post/59e4c02151882578d02f4aca">掘金：谈谈 HTTPS</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、http&quot;&gt;&lt;a href=&quot;#一、http&quot; class=&quot;headerlink&quot; title=&quot;一、http&quot;&gt;&lt;/a&gt;一、http&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/11/163e</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="网络协议" scheme="http://chajianyuanblog.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>浏览器：一个URL从输入到显示的过程</title>
    <link href="http://chajianyuanblog.com/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://chajianyuanblog.com/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2020-03-24T12:29:48.000Z</published>
    <updated>2020-03-24T12:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、查找浏览器缓存，如果没有则进行-DNS-解析"><a href="#1、查找浏览器缓存，如果没有则进行-DNS-解析" class="headerlink" title="1、查找浏览器缓存，如果没有则进行 DNS 解析"></a>1、查找浏览器缓存，如果没有则进行 DNS 解析</h3><p>当在浏览器中输入一个 URL 时，最开始要去浏览器缓存中查找，浏览器缓存分为强缓存和协商缓存，强缓存指不需要向服务器发送请求，直接从缓存中读取资源，状态码为 200，协商缓存是指当强缓存失效后，浏览器携带缓存标识向服务器发送请求，如果资源没有改变就返回 304，更新缓存，如果资源改变就返回 200 和新的资源，如果浏览器中不存在缓存，就通过 DNS 服务器启动一个 DNS 查询，获得 URL 对应的 IP 地址</p><h3 id="2、TCP-连接：TCP-三次握手"><a href="#2、TCP-连接：TCP-三次握手" class="headerlink" title="2、TCP 连接：TCP 三次握手"></a>2、TCP 连接：TCP 三次握手</h3><ul><li>第一次握手，由浏览器发起，告诉服务器我要发起请求了</li><li>第二次握手，由服务器发起，告诉浏览器，我已经准备接收了，你可以发送请求了</li><li>第三次握手，由浏览器发起，告诉服务器，我马上发送了，准备接收吧</li></ul><p><strong>三次握手的目的</strong>：防止已失效的连接请求报文段突然又传送到了服务器端，因而产生错误</p><h3 id="3、发送-HTTP-请求"><a href="#3、发送-HTTP-请求" class="headerlink" title="3、发送 HTTP 请求"></a>3、发送 HTTP 请求</h3><h3 id="4、服务器处理请求并返回-HTTP-报文"><a href="#4、服务器处理请求并返回-HTTP-报文" class="headerlink" title="4、服务器处理请求并返回 HTTP 报文"></a>4、服务器处理请求并返回 HTTP 报文</h3><h3 id="5、浏览器解析渲染页面"><a href="#5、浏览器解析渲染页面" class="headerlink" title="5、浏览器解析渲染页面"></a>5、浏览器解析渲染页面</h3><ol><li>根据 HTML 解析 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ol><h3 id="6、断开连接：TCP-四次挥手"><a href="#6、断开连接：TCP-四次挥手" class="headerlink" title="6、断开连接：TCP 四次挥手"></a>6、断开连接：TCP 四次挥手</h3><p><a href="https://juejin.im/post/5bf3ad55f265da61682afc9b">掘金：从 URL 输入到页面展现到底发生什么？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、查找浏览器缓存，如果没有则进行-DNS-解析&quot;&gt;&lt;a href=&quot;#1、查找浏览器缓存，如果没有则进行-DNS-解析&quot; class=&quot;headerlink&quot; title=&quot;1、查找浏览器缓存，如果没有则进行 DNS 解析&quot;&gt;&lt;/a&gt;1、查找浏览器缓存，如果没有</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="浏览器" scheme="http://chajianyuanblog.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>css：css的引入方式</title>
    <link href="http://chajianyuanblog.com/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>http://chajianyuanblog.com/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-22T01:48:54.000Z</published>
    <updated>2020-03-22T01:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、css-的引入方式有三种"><a href="#1、css-的引入方式有三种" class="headerlink" title="1、css 的引入方式有三种"></a>1、css 的引入方式有三种</h3><p>（1）行内式将样式写在元素的 style 属性里面</p><p>（2）内嵌式将样式写在&lt; style &gt;元素里面</p><p>（3）外链式指通过 link 标签引入 css 文件</p><h3 id="2、link-和-import-引入样式文件的区别"><a href="#2、link-和-import-引入样式文件的区别" class="headerlink" title="2、link 和@import 引入样式文件的区别"></a>2、link 和@import 引入样式文件的区别</h3><p>（1）加载资源的限制</p><p>link 是 XHTML 的标签，除了加载 css 文件之外，还能加载 RSS 等其他事务，如加载模板等；</p><p>@import 只能加载 css 文件</p><p>（2）加载方式</p><p>用 link 引用 css，在页面载入时同时加载，即同步加载；</p><p>用@import 引用 css，则需要等到网页完全载入后，再加载 css 文件，即异步加载</p><p>（3）兼容性</p><p>link 是 XHTML 标签，没有兼容问题</p><p>@import 是在 css2.1 中提出的，不支持低版本的浏览器</p><p>（4）改变样式</p><p>link 的标签是 DOM 元素，支持使用 JavaScript 控制 DOM 和修改样式</p><p>@import 是一种方法，不支持控制 DOM 和修改元素</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、css-的引入方式有三种&quot;&gt;&lt;a href=&quot;#1、css-的引入方式有三种&quot; class=&quot;headerlink&quot; title=&quot;1、css 的引入方式有三种&quot;&gt;&lt;/a&gt;1、css 的引入方式有三种&lt;/h3&gt;&lt;p&gt;（1）行内式将样式写在元素的 style 属</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="css" scheme="http://chajianyuanblog.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JS：map、filter、reduce</title>
    <link href="http://chajianyuanblog.com/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/"/>
    <id>http://chajianyuanblog.com/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/</id>
    <published>2020-03-22T01:28:46.000Z</published>
    <updated>2020-03-22T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、map"><a href="#1、map" class="headerlink" title="1、map"></a>1、map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3]</span><br><span class="line">arr.map((item, index, array)&#x3D;&gt; item &#x3D; item+1)  &#x3D;&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure><p><code>map</code>的回调函数可接受三个参数，遍历原数组，对每个元素进行操作，返回一个新数组。</p><h3 id="2、filter"><a href="#2、filter" class="headerlink" title="2、filter"></a>2、filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3]</span><br><span class="line">arr.map((item, index, array)&#x3D;&gt; item !&#x3D; 2)  &#x3D;&gt; [1, 3]</span><br></pre></td></tr></table></figure><p><code>filter</code> 的回调函数也可以接受三个参数，在遍历原数组事，将返回值为 true 的元素放在新数组中，返回新数组。</p><h3 id="3、reduce"><a href="#3、reduce" class="headerlink" title="3、reduce"></a>3、reduce</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3]</span><br><span class="line">arr.map((acc, current) &#x3D;&gt; acc+ current, 0)  &#x3D;&gt; 6</span><br></pre></td></tr></table></figure><p><code>reduce</code>接收两个参数，分别是回调函数和初始值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、map&quot;&gt;&lt;a href=&quot;#1、map&quot; class=&quot;headerlink&quot; title=&quot;1、map&quot;&gt;&lt;/a&gt;1、map&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="javascript" scheme="http://chajianyuanblog.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>总结：React</title>
    <link href="http://chajianyuanblog.com/2020/03/09/%E6%80%BB%E7%BB%93%EF%BC%9AReact/"/>
    <id>http://chajianyuanblog.com/2020/03/09/%E6%80%BB%E7%BB%93%EF%BC%9AReact/</id>
    <published>2020-03-09T02:52:51.000Z</published>
    <updated>2020-09-23T03:29:08.670Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、当调用-setState-的时候-发生了什么？"><a href="#一、当调用-setState-的时候-发生了什么？" class="headerlink" title="一、当调用 setState 的时候,发生了什么？"></a>一、当调用 setState 的时候,发生了什么？</h2><p>当调用 setState 时，React 做的第一件事就是将传递给 setState 的对象合并到组件的当前状态，这将启动一个称为和解的过程，和解的最终目标是，根据这个新的状态以最有效的方式更新 DOM。为此，React 将构建一个新的 React 虚拟 DOM 树（可以将其视为页面 DOM 元素的对象表示方式）。</p><p>一旦有了这个 DOM 树，为了弄清 DOM 是如何响应新的状态而改变的，React 会将这个新树与上一个虚拟 DOM 树比较。</p><p>这样做，React 会知道发生的确切变化，并且通过了解发生的变化后，在绝对必要的情况下进行更新 DOM，即可将因操作 DOM 而占用的空间最小化。</p><h2 id="二、在-React-中元素（element）和组件（component）有什么区别？"><a href="#二、在-React-中元素（element）和组件（component）有什么区别？" class="headerlink" title="二、在 React 中元素（element）和组件（component）有什么区别？"></a>二、在 React 中元素（element）和组件（component）有什么区别？</h2><p>简单的说，在 React 中元素（虚拟 DOM）描述了你在屏幕上看到的 DOM 元素。换个说法就是，在 React 中元素是页面中 DOM 元素的对象表示方式，在 React 中组件是一个函数或一个类，它可以接受输入并返回一个元素。</p><blockquote><p>提醒：工作中，为了提高开发效率，通常使用 JSX 语法表示 React 元素（虚拟 DOM）。在编译的时候，把它转化成一个 React.creatElement 调用方法。</p></blockquote><h2 id="三、什么时候使用类组件（Class-Component）？什么时候使用功能组件（Functional-Component）？"><a href="#三、什么时候使用类组件（Class-Component）？什么时候使用功能组件（Functional-Component）？" class="headerlink" title="三、什么时候使用类组件（Class Component）？什么时候使用功能组件（Functional Component）？"></a>三、什么时候使用类组件（Class Component）？什么时候使用功能组件（Functional Component）？</h2><p>如果使用组件具有状态（state）或生命周期方法，请使用类组件；否则使用功能组件。</p><h2 id="四、什么是-React-的-refs？为什么它们很重要？"><a href="#四、什么是-React-的-refs？为什么它们很重要？" class="headerlink" title="四、什么是 React 的 refs？为什么它们很重要？"></a>四、什么是 React 的 refs？为什么它们很重要？</h2><p>refs 允许你直接访问 DOM 元素或组件实例，为了使用它们，可以向组件添加一个 ref 属性。</p><p>如果该属性的值是一个回调函数，它将接受底层的 DOM 元素或组件的已挂载实例作为其第一个参数。可以在组件中存储它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export class App extends Component &#123;</span><br><span class="line">  showResult() &#123;</span><br><span class="line">    console.log(this.input.value);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123; input &#x3D;&gt; this.input &#x3D; input&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123; this.showResult.bind(this) &#125;&gt; 展示结果 &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该属性值是一个字符串，React 将会在组件实例化对象的 refs 属性中，存储一个同名属性，该属性是对这个 DOM 元素的引用，可以通过原生的 DOM API 操作它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export class App extends Component &#123;</span><br><span class="line">  showResult() &#123;</span><br><span class="line">    console.log(this.refs.username.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.showResult.bind(this)&#125;&gt;展示结果&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、React-中的-key-是什么？为什么它们很重要？"><a href="#五、React-中的-key-是什么？为什么它们很重要？" class="headerlink" title="五、React 中的 key 是什么？为什么它们很重要？"></a>五、React 中的 key 是什么？为什么它们很重要？</h2><p>key 可以帮助 React 跟踪循环创建列表中的虚拟 DOM 元素，了解哪些元素已更改、添加或删除。</p><p>每个绑定 key 的虚拟 DOM 元素，在兄弟元素之间都是独一无二的。在 React 的和解过程中，比较新的虚拟 DOM 树与上一个虚拟 DOM 树之间的差异，并映射到页面中。key 使 React 处理列表中虚拟 DOM 时更加高效，因为 React 可以使用虚拟 DOM 上的 key 属性，快速了解元素是新的，还是需要删除的，还是修改过的。如果没有 key，React 就不知道列表中虚拟 DOM 元素与页面中的哪个元素相对应，所以在创建列表的时候，不要忽略 key。</p><h2 id="六、如果创建了类似于下面的-Icketang-元素，那么该如何实现-Icketang-类？"><a href="#六、如果创建了类似于下面的-Icketang-元素，那么该如何实现-Icketang-类？" class="headerlink" title="六、如果创建了类似于下面的 Icketang 元素，那么该如何实现 Icketang 类？"></a>六、如果创建了类似于下面的 Icketang 元素，那么该如何实现 Icketang 类？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;Icketang username&#x3D;&quot;雨夜清荷&quot;&gt;</span><br><span class="line">  &#123;user &#x3D;&gt; user ? &lt;Info user&#x3D;&#123;user&#125; &#x2F;&gt; : &lt;Loading &#x2F;&gt;&#125;</span><br><span class="line">&lt;&#x2F;Icketang&gt;</span><br><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">export class Icketang extends Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 请实现代码</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      user: props.user</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    &#x2F;&#x2F; 模拟异步获取数据操作，更新状态</span><br><span class="line">    setTimeout(()&#x3D;&gt; this.setState(&#123;</span><br><span class="line">      user: &#39;爱创课堂&#39;</span><br><span class="line">    &#125;), 2000)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return this.props.children(this.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Loading extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;p&gt;Loading...&lt;&#x2F;p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Info extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;&#123;this.props.user&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、约束性组件（controlled-component）与非约束性组件（uncontrolled-component）有什么区别？"><a href="#七、约束性组件（controlled-component）与非约束性组件（uncontrolled-component）有什么区别？" class="headerlink" title="七、约束性组件（controlled component）与非约束性组件（uncontrolled component）有什么区别？"></a>七、约束性组件（controlled component）与非约束性组件（uncontrolled component）有什么区别？</h2><p>在 React 中，组件负责控制和管理自己的状态。</p><p>如果将 HTML 中的表单元素（input、select、textarea 等）添加到组件中，当用户与表单发生交互时，就设计表单数据存储问题。根据表单数据存储问题。根据表单数据的存储位置，将组件分成约束性组件和非约束性组件。</p><p>约束性组件（controlled component）就是由 React 控制的组件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、当调用-setState-的时候-发生了什么？&quot;&gt;&lt;a href=&quot;#一、当调用-setState-的时候-发生了什么？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JS：赋值、深拷贝和浅拷贝</title>
    <link href="http://chajianyuanblog.com/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://chajianyuanblog.com/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-02-24T00:46:35.000Z</published>
    <updated>2020-02-24T00:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、浅拷贝和深拷贝"><a href="#一、浅拷贝和深拷贝" class="headerlink" title="一、浅拷贝和深拷贝"></a>一、浅拷贝和深拷贝</h2><p>浅拷贝和深拷贝只针对 object 和 array 这种引用数据类型。</p><p><strong>浅拷贝：</strong> 只复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p><p><strong>深拷贝：</strong> 会创造一个一模一样的新对象，新对象和原对象不共享内存，修改新对象不会改到原对象。</p><h2 id="二、赋值和浅拷贝"><a href="#二、赋值和浅拷贝" class="headerlink" title="二、赋值和浅拷贝"></a>二、赋值和浅拷贝</h2><p><strong>赋值：</strong> 当把某个对象赋值给一个新的变量时，赋的是该对象在栈中的地址，而不是堆中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D;&#123;</span><br><span class="line">  name: &quot;zhangsan&quot;,</span><br><span class="line">  scores: [100, 99]</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; a;</span><br></pre></td></tr></table></figure><p>其实是将对象 a 在栈中的指针 a 赋值给了对象 b,指针 a 和指针 b 指向的是同一个堆中的数据，那么其中一个数据改变时，另外一个也会改变。</p><p><strong>浅拷贝：</strong> 浅拷贝会创建一个新的对象，但它是按位拷贝对象，即如果原对象的属性是基本类型，则拷贝的是基本数据类型的值；如果原对象的属性是引用数据类型，则拷贝的是引用类型的指针。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/23/167da74d45d3103b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="三、浅拷贝的实现方式"><a href="#三、浅拷贝的实现方式" class="headerlink" title="三、浅拷贝的实现方式"></a>三、浅拷贝的实现方式</h2><h3 id="1、Object-assign"><a href="#1、Object-assign" class="headerlink" title="1、Object.assign()"></a>1、Object.assign()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: &#39;zhangsan&#39;,</span><br><span class="line">    b: &#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var copyObj &#x3D; Object.assign(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure><h3 id="2、Array-prototype-concat"><a href="#2、Array-prototype-concat" class="headerlink" title="2、Array.prototype.concat()"></a>2、Array.prototype.concat()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: &#39;zhangsan&#39;,</span><br><span class="line">    b: &#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var copyObj &#x3D; obj.concat();</span><br></pre></td></tr></table></figure><h3 id="3、Array-prototype-slice"><a href="#3、Array-prototype-slice" class="headerlink" title="3、Array.prototype.slice()"></a>3、Array.prototype.slice()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: &#39;zhangsan&#39;,</span><br><span class="line">    b: &#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var copyObj &#x3D; obj.slice();</span><br></pre></td></tr></table></figure><h2 id="四、深拷贝的实现方式"><a href="#四、深拷贝的实现方式" class="headerlink" title="四、深拷贝的实现方式"></a>四、深拷贝的实现方式</h2><h3 id="1、JSON-parse-JSON-stringify"><a href="#1、JSON-parse-JSON-stringify" class="headerlink" title="1、JSON.parse(JSON.stringify())"></a>1、JSON.parse(JSON.stringify())</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: &#39;zhangsan&#39;,</span><br><span class="line">    b: &#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var copyObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br></pre></td></tr></table></figure><h3 id="2、手写递归方法"><a href="#2、手写递归方法" class="headerlink" title="2、手写递归方法"></a>2、手写递归方法</h3><p>遍历对象、数组直到里面都是基本数据类型，然后再去复制。</p><h3 id="3、函数库-lodash"><a href="#3、函数库-lodash" class="headerlink" title="3、函数库 lodash"></a>3、函数库 lodash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var _ &#x3D; require(&#39;lodash&#39;);</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: &#39;zhangsan&#39;,</span><br><span class="line">    b: &#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var copyObj &#x3D; _.cloneDeep(obj);</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5b5dcf8351882519790c9a2e">浅拷贝与深拷贝</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、浅拷贝和深拷贝&quot;&gt;&lt;a href=&quot;#一、浅拷贝和深拷贝&quot; class=&quot;headerlink&quot; title=&quot;一、浅拷贝和深拷贝&quot;&gt;&lt;/a&gt;一、浅拷贝和深拷贝&lt;/h</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="javascript" scheme="http://chajianyuanblog.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>react：有状态组件和无状态组件</title>
    <link href="http://chajianyuanblog.com/2020/02/11/react%EF%BC%9A%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6/"/>
    <id>http://chajianyuanblog.com/2020/02/11/react%EF%BC%9A%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6/</id>
    <published>2020-02-11T01:06:30.000Z</published>
    <updated>2020-09-23T03:31:13.162Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="一、React-中创建组件的方式"><a href="#一、React-中创建组件的方式" class="headerlink" title="一、React 中创建组件的方式"></a>一、React 中创建组件的方式</h3><h4 id="1、ES5：React-createClass"><a href="#1、ES5：React-createClass" class="headerlink" title="1、ES5：React.createClass"></a>1、ES5：React.createClass</h4><h4 id="2、ES6：React-Component"><a href="#2、ES6：React-Component" class="headerlink" title="2、ES6：React.Component"></a>2、ES6：React.Component</h4><h4 id="3、无状态函数"><a href="#3、无状态函数" class="headerlink" title="3、无状态函数"></a>3、无状态函数</h4><h3 id="一、有状态组件"><a href="#一、有状态组件" class="headerlink" title="一、有状态组件"></a>一、有状态组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      name: &#39;hello world&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">  const &#123;name&#125; &#x3D; this.state;</span><br><span class="line">  const &#123;title&#125; &#x3D; this.props;</span><br><span class="line">    return(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;title&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default A;</span><br></pre></td></tr></table></figure><h3 id="二、无状态组件"><a href="#二、无状态组件" class="headerlink" title="二、无状态组件"></a>二、无状态组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const B &#x3D; (props)&#x3D;&gt; &#123;</span><br><span class="line">  const [name, setName] &#x3D; useState(&#39;hello world&#39;);</span><br><span class="line">  const &#123;title&#125; &#x3D; props;</span><br><span class="line">  return(</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">       &lt;div&gt;&#123;title&#125;&lt;&#x2F;div&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default B;</span><br></pre></td></tr></table></figure><p>无状态组件主要用来定义模板，接收来自父组件 props 传递过来的数据。</p><p>无状态组件应该保持模板的纯粹性，以便组件的复用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h3 id=&quot;一、React-中创建组件的方式&quot;&gt;&lt;a href=&quot;#一、React-中创建组件的方式&quot; class=&quot;headerlink&quot; title=&quot;一、React 中创建组件</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="react" scheme="http://chajianyuanblog.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>css：单列、两列、三列布局</title>
    <link href="http://chajianyuanblog.com/2019/10/27/css%EF%BC%9A%E5%8D%95%E5%88%97%E3%80%81%E4%B8%A4%E5%88%97%E3%80%81%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/"/>
    <id>http://chajianyuanblog.com/2019/10/27/css%EF%BC%9A%E5%8D%95%E5%88%97%E3%80%81%E4%B8%A4%E5%88%97%E3%80%81%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/</id>
    <published>2019-10-27T09:06:35.000Z</published>
    <updated>2020-09-23T03:29:16.663Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、单列布局"><a href="#一、单列布局" class="headerlink" title="一、单列布局"></a>一、单列布局</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/7/166ed4e13cc2753f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="1、header-content-和-footer-等宽的单列布局"><a href="#1、header-content-和-footer-等宽的单列布局" class="headerlink" title="1、header,content 和 footer 等宽的单列布局"></a>1、header,content 和 footer 等宽的单列布局</h3><p>先通过对 header,content,footer 统一设置<code>width:1000px</code>或者<code>max-width:1000px</code> （这两者的区别是当屏幕小于 1000px 时，前者会出现滚动条，后者则不会，显示实际宽度），然后设置<code>margin:auto</code> 实现居中即可得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.header,</span><br><span class="line">.content,</span><br><span class="line">.footer &#123;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">max-width: 1000px;</span><br><span class="line">&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">height: 200px;</span><br><span class="line">background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="2、header-与-footer-等宽，content-略窄的单列布局"><a href="#2、header-与-footer-等宽，content-略窄的单列布局" class="headerlink" title="2、header 与 footer 等宽，content 略窄的单列布局"></a>2、header 与 footer 等宽，content 略窄的单列布局</h3><p>header、footer 的内容宽度不设置，块级元素充满整个屏幕，但 header、content、footer 的内容区设置同一个 width，并通过 margin：0 auto 实现居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;nav&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.header,</span><br><span class="line">.content,</span><br><span class="line">.footer,</span><br><span class="line">.nav &#123;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">max-width: 1000px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">  .nav &#123;</span><br><span class="line">max-width: 800px;</span><br><span class="line">height: 10px;</span><br><span class="line">background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 200px;</span><br><span class="line">background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.footer &#123;</span><br><span class="line">max-width: 1000px;</span><br><span class="line">height: 100px;</span><br><span class="line">background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="二、两列布局"><a href="#二、两列布局" class="headerlink" title="二、两列布局"></a>二、两列布局</h2><h3 id="1、利用-float-配合-margin-实现"><a href="#1、利用-float-配合-margin-实现" class="headerlink" title="1、利用 float 配合 margin 实现"></a>1、利用 float 配合 margin 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .box &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      .box &gt; div &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">      .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        background-color: red;</span><br><span class="line">        width: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">      .right &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        margin-left: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="2、利用-float-配合-overflow-实现"><a href="#2、利用-float-配合-overflow-实现" class="headerlink" title="2、利用 float 配合 overflow 实现"></a>2、利用 float 配合 overflow 实现</h3><p>如果是普通的两列布局，<strong>浮动+普通元素的 margin ** 便可以实现，但如果是自适应的两列布局，利用</strong>float+overflow:hidden** 便可以实现，这种办法主要是通过 overflow 触发 BFC，因为 BFC 不会重叠浮动元素，由于设置 overflow:hidden 并不会触发 IE6-浏览器的 laslayout 属性，所以需要设置 zoom:1 来兼容 IE6-浏览器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    zoom: 1;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="3、使用-flex-实现"><a href="#3、使用-flex-实现" class="headerlink" title="3、使用 flex 实现"></a>3、使用 flex 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="4、grid-布局"><a href="#4、grid-布局" class="headerlink" title="4、grid 布局"></a>4、grid 布局</h3><p>Grid 布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">    &lt;p&gt;left&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">    &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    background-color: aqua;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-columns: auto 1fr;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="三、三列布局"><a href="#三、三列布局" class="headerlink" title="三、三列布局"></a>三、三列布局</h2><p><strong>特征：中间列自适应宽度，旁边两侧固定宽度</strong></p><h3 id="1、圣杯布局"><a href="#1、圣杯布局" class="headerlink" title="1、圣杯布局"></a>1、圣杯布局</h3><h4 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h4><p>比较特殊的三栏布局，同样也是两固定宽度，中间自适应，唯一的区别是 dom 结构必须是先写中间列部分，这样实现中间列可以优先加载。</p><h4 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h4><ul><li><p>三个部分都设定为左浮动，否则左右两边内容上不去，就不可能和中间列同一行，然后设置 center 的宽度为 100%（实现中间列内容自适应），此时，left 和 right 部分会跳到下一行。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16682cae82722a6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p></li><li><p>通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16682c1d72a1ea68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p></li><li><p>通过设置父容器的 padding-left 和 padding-right，让左右两边留出间隙</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/16682c473f605745?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p></li><li><p>通过设置相对定位，让 left 和 right 部分移动到两边</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16682bf3615502c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p></li></ul><h4 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h4><ul><li><p>center 部分的最小宽度不能小于 left 部分的宽度，否则 left 部分会掉到下一行</p></li><li><p>如果其中一列内容高度拉长，其他两列的背景并不会自动填充（借助等高布局正 padding+负 padding 可解决）</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/8/166f229b862b187f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;center&quot;&gt;圣杯布局&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .left,</span><br><span class="line">  .center,</span><br><span class="line">  .right &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .container &#123;</span><br><span class="line">    padding-left: 100px;   &#x2F;&#x2F;为左右栏腾出空间</span><br><span class="line">    padding-right: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    position: relative;</span><br><span class="line">    left: -100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .center &#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    width: 100%;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin-left: -100px;</span><br><span class="line">    position: relative;</span><br><span class="line">    right: -100px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="2、双飞翼布局"><a href="#2、双飞翼布局" class="headerlink" title="2、双飞翼布局"></a>2、双飞翼布局</h3><h4 id="2-1-特点"><a href="#2-1-特点" class="headerlink" title="2.1 特点"></a>2.1 特点</h4><p>同样是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错误问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。</p><h4 id="2-2-实现步骤（前两步与圣杯布局）"><a href="#2-2-实现步骤（前两步与圣杯布局）" class="headerlink" title="2.2 实现步骤（前两步与圣杯布局）"></a>2.2 实现步骤（前两步与圣杯布局）</h4><ul><li>三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行</li><li>通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行</li><li>center 部分增加一个内层 div，并设<code>margin：0 200px</code>；</li></ul><h4 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h4><p>多加一层 dom 树节点，增加渲染树生成的计算量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;main col&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main_inner&quot;&gt;main&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;left col&quot;&gt;left&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;right col&quot;&gt;right&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  body,</span><br><span class="line">  html,</span><br><span class="line">  container &#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    padding: 0;</span><br><span class="line">    margin: 0;</span><br><span class="line">  &#125;</span><br><span class="line">  .col &#123;</span><br><span class="line">    float: left; &#x2F;*把left和right定位到左右不分*&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">  .main &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;*处理中间栏被遮盖问题*&#x2F;</span><br><span class="line">  .main_inner &#123;</span><br><span class="line">    margin: 0 200px 0 100px;</span><br><span class="line">  &#125;</span><br><span class="line">  .left &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100%;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">    background-color: green;</span><br><span class="line">  &#125;</span><br><span class="line">  .right &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100%;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p><strong>对比圣杯布局和双飞翼布局</strong></p><p>（1）都是左右栏定宽，中间自适应的三栏布局，中间栏都放在文档流前面，保证先行渲染</p><p>（2）解决方案基本相似：都是三栏全部设置左浮动<code>float: left</code> ，然后分别解决中间栏内容被覆盖问题</p><p>（3）解决中间栏内容被覆盖问题时，圣杯布局设置父元素的 padding，双飞翼布局在中间栏外面嵌套了一个 div，并设置 margin，实际上双飞翼布局就是圣杯布局的改进方案</p><h3 id="3、flex-布局"><a href="#3、flex-布局" class="headerlink" title="3、flex 布局"></a>3、flex 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;main&quot;&gt;main&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .container &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">      &#125;</span><br><span class="line">      .left &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line">      .main &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        background-color: blue;</span><br><span class="line">      &#125;</span><br><span class="line">      .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: green;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="4、流体布局"><a href="#4、流体布局" class="headerlink" title="4、流体布局"></a>4、流体布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .left,</span><br><span class="line">      .right,</span><br><span class="line">      .main &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line">      .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">      &#125;</span><br><span class="line">      .main &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        margin-left: 100px;</span><br><span class="line">        margin-right: 100px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：主要内容无法最先加载，当页面内容较多时会影响用户体验</p><h3 id="5、BFC-三栏布局"><a href="#5、BFC-三栏布局" class="headerlink" title="5、BFC 三栏布局"></a>5、BFC 三栏布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .left,</span><br><span class="line">      .right,</span><br><span class="line">      .main &#123;</span><br><span class="line">        height: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line">      .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">      &#125;</span><br><span class="line">      .main &#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5bbcd7ff5188255c80668028">几种常见的 CSS 布局</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、单列布局&quot;&gt;&lt;a href=&quot;#一、单列布局&quot; class=&quot;headerlink&quot; title=&quot;一、单列布局&quot;&gt;&lt;/a&gt;一、单列布局&lt;/h2&gt;&lt;p&gt;&lt;img sr</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="css" scheme="http://chajianyuanblog.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css：BFC规范</title>
    <link href="http://chajianyuanblog.com/2019/10/27/css%EF%BC%9ABFC%E8%A7%84%E8%8C%83/"/>
    <id>http://chajianyuanblog.com/2019/10/27/css%EF%BC%9ABFC%E8%A7%84%E8%8C%83/</id>
    <published>2019-10-27T03:00:05.000Z</published>
    <updated>2020-02-22T06:10:21.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><p>BFC（Block formatting context，块级格式化上下文），他是一个独立的渲染区域，只有 Block-level box 参与，他规定了内部的 Block-level box 如何布局，并且与这个区域外部毫不相干。通俗的讲，BFC 是一个容器，用于管理块级元素。</p><h2 id="2、BFC-主要特征"><a href="#2、BFC-主要特征" class="headerlink" title="2、BFC 主要特征"></a>2、BFC 主要特征</h2><ul><li>BFC 容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的 BFC 来解决垂直边距折叠问题</li><li>BFC 不会重叠浮动元素</li><li>BFC 可以包含浮动</li></ul><h2 id="3、BFC-触发方式"><a href="#3、BFC-触发方式" class="headerlink" title="3、BFC 触发方式"></a>3、BFC 触发方式</h2><ul><li>float 为 left|right</li><li>overflow 为 hidden|auto|scroll</li><li>display 为 table-cell|table-caption|inline-block</li><li>position 为 absolute|fixed</li></ul><p><a href="https://juejin.im/post/5bc33d0d6fb9a05d1658afc7">深入理解 BFC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;1、定义&quot;&gt;&lt;a href=&quot;#1、定义&quot; class=&quot;headerlink&quot; title=&quot;1、定义&quot;&gt;&lt;/a&gt;1、定义&lt;/h2&gt;&lt;p&gt;BFC（Block forma</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="css" scheme="http://chajianyuanblog.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>html：WebSocket学习</title>
    <link href="http://chajianyuanblog.com/2019/10/26/html%EF%BC%9AwebSocket%E5%AD%A6%E4%B9%A0/"/>
    <id>http://chajianyuanblog.com/2019/10/26/html%EF%BC%9AwebSocket%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-10-26T09:37:18.000Z</published>
    <updated>2020-09-23T03:30:28.777Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017051502.png"></p><p><strong>特点</strong></p><ul><li>服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送消息，是真正的双向平等对话，属于服务器推送技术的一种</li><li>建立在 TCP 协议之上，服务器端的实现比较容易</li><li>与 HTTP 协议有着良好的兼容性，默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>可以发送文本，也可以发送二进制数据</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标志符是 ws（如果加密，则为 wss），服务器网址就是 URL。</li></ul><h2 id="二、客户端的简单实例"><a href="#二、客户端的简单实例" class="headerlink" title="二、客户端的简单实例"></a>二、客户端的简单实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ws &#x3D; new WebSocket(&quot;wss:&#x2F;&#x2F;echo.websocket.org&quot;);</span><br><span class="line"></span><br><span class="line">ws.onopen &#x3D; function(evt) &#123;</span><br><span class="line">  console.log(&quot;Connection open ...&quot;);</span><br><span class="line">  ws.send(&quot;Hello WebSockets!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage &#x3D; function(evt) &#123;</span><br><span class="line">  console.log( &quot;Received Message: &quot; + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose &#x3D; function(evt) &#123;</span><br><span class="line">  console.log(&quot;Connection closed.&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、客户端的-API"><a href="#三、客户端的-API" class="headerlink" title="三、客户端的 API"></a>三、客户端的 API</h2><h3 id="1、WebSocket-构造函数"><a href="#1、WebSocket-构造函数" class="headerlink" title="1、WebSocket 构造函数"></a>1、WebSocket 构造函数</h3><p><code>websocket</code>对象作为一个构造函数，用于新建一个<code>websocket</code>实例</p><p><code>var ws = new WebSocket(&#39;ws://localhost:8080&#39;);</code></p><p>执行上面语句之后，客户端就会与服务器进行连接</p><h3 id="2、webSocket-readyState"><a href="#2、webSocket-readyState" class="headerlink" title="2、webSocket.readyState"></a>2、webSocket.readyState</h3><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p><ul><li><code>CONNECTING</code>：值为 0，表示正在连接</li><li><code>OPEN</code>：值为 1，表示连接成功，可以通信了</li><li><code>CLOSING</code>：值为 2，表示连接正在关闭</li><li><code>CLOSED</code>：值为 3，表示连接已经关闭，或者打开连接失败</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">switch (ws.readyState) &#123;</span><br><span class="line">  case WebSocket.CONNECTING:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.OPEN:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSING:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSED:</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    &#x2F;&#x2F; this never happens</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、webSocket-onopen"><a href="#3、webSocket-onopen" class="headerlink" title="3、webSocket.onopen"></a>3、webSocket.onopen</h3><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen &#x3D; function () &#123;</span><br><span class="line">  ws.send(&#39;Hello Server!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.addEventListener(&#39;open&#39;, function (event) &#123;</span><br><span class="line">  ws.send(&#39;Hello Server!&#39;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4、webSocket-onclose"><a href="#4、webSocket-onclose" class="headerlink" title="4、webSocket.onclose"></a>4、webSocket.onclose</h3><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose &#x3D; function(event) &#123;</span><br><span class="line">  var code &#x3D; event.code;</span><br><span class="line">  var reason &#x3D; event.reason;</span><br><span class="line">  var wasClean &#x3D; event.wasClean;</span><br><span class="line">  &#x2F;&#x2F; handle close event</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(&quot;close&quot;, function(event) &#123;</span><br><span class="line">  var code &#x3D; event.code;</span><br><span class="line">  var reason &#x3D; event.reason;</span><br><span class="line">  var wasClean &#x3D; event.wasClean;</span><br><span class="line">  &#x2F;&#x2F; handle close event</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5、webSocket-onmessage"><a href="#5、webSocket-onmessage" class="headerlink" title="5、webSocket.onmessage"></a>5、webSocket.onmessage</h3><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage &#x3D; function(event) &#123;</span><br><span class="line">  var data &#x3D; event.data;</span><br><span class="line">  &#x2F;&#x2F; 处理数据</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(&quot;message&quot;, function(event) &#123;</span><br><span class="line">  var data &#x3D; event.data;</span><br><span class="line">  &#x2F;&#x2F; 处理数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage &#x3D; function(event)&#123;</span><br><span class="line">  if(typeof event.data &#x3D;&#x3D;&#x3D; String) &#123;</span><br><span class="line">    console.log(&quot;Received data string&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if(event.data instanceof ArrayBuffer)&#123;</span><br><span class="line">    var buffer &#x3D; event.data;</span><br><span class="line">    console.log(&quot;Received arraybuffer&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显示指定收到的二进制数据类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 收到的是 blob 数据</span><br><span class="line">ws.binaryType &#x3D; &quot;blob&quot;;</span><br><span class="line">ws.onmessage &#x3D; function(e) &#123;</span><br><span class="line">  console.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 收到的是 ArrayBuffer 数据</span><br><span class="line">ws.binaryType &#x3D; &quot;arraybuffer&quot;;</span><br><span class="line">ws.onmessage &#x3D; function(e) &#123;</span><br><span class="line">  console.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6、webSocket-send"><a href="#6、webSocket-send" class="headerlink" title="6、webSocket.send()"></a>6、webSocket.send()</h3><p>实例对象的<code>send()</code> 方法用于向服务器发送数据</p><p>发送文本的例子</p><p><code>ws.send(&#39;your message&#39;);</code></p><p>发送 Blob 对象的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var file &#x3D; document.querySelector(&#39;input[type&#x3D;&quot;file&quot;]&#39;).files[0];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure><p>发送<code>ArrayBuffer</code>对象的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Sending canvas ImageData as ArrayBuffer</span><br><span class="line">var img &#x3D; canvas_context.getImageData(0, 0, 400, 320);</span><br><span class="line">var binary &#x3D; new Uint8Array(img.data.length);</span><br><span class="line">for (var i &#x3D; 0; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] &#x3D; img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure><h3 id="7、webSocket-bufferedAmount"><a href="#7、webSocket-bufferedAmount" class="headerlink" title="7、webSocket.bufferedAmount"></a>7、webSocket.bufferedAmount</h3><p>实例对象的<code>bufferedAmount</code> 属性，表示还有多少字节的二进制数据没有发送出去，他可以用来判断发送是否结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; new ArrayBuffer(10000000);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line">if (socket.bufferedAmount &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">  &#x2F;&#x2F; 发送完毕</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 发送还没结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、webSocket-onerror"><a href="#8、webSocket-onerror" class="headerlink" title="8、webSocket.onerror"></a>8、webSocket.onerror</h3><p>实现对象的<code>onerror</code> 属性，用于指定报错时的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror &#x3D; function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; handle error event</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(&quot;error&quot;, function(event) &#123;</span><br><span class="line">  &#x2F;&#x2F; handle error event</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>详细参见<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰 WebSocket 教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http:</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="html" scheme="http://chajianyuanblog.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>html：cookie、session、sessionStorage、localStorage详细讲解</title>
    <link href="http://chajianyuanblog.com/2019/10/26/html%EF%BC%9Acookie%E3%80%81sessionStorage%E3%80%81localStorage%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
    <id>http://chajianyuanblog.com/2019/10/26/html%EF%BC%9Acookie%E3%80%81sessionStorage%E3%80%81localStorage%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/</id>
    <published>2019-10-26T06:45:47.000Z</published>
    <updated>2020-02-22T06:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、cookie"><a href="#一、cookie" class="headerlink" title="一、cookie"></a>一、cookie</h2><h3 id="1、cookie-的来源"><a href="#1、cookie-的来源" class="headerlink" title="1、cookie 的来源"></a>1、cookie 的来源</h3><p>cookie 的本质工作并非本地存储，而是“维持状态”。因为<strong>http 协议是无状态的，http 协议本身并不对请求和响应之间的通信状态进行保存</strong>，通常来说，服务器不知道用户上一次做了什么。</p><h3 id="2、什么是-cookie-及应用场景"><a href="#2、什么是-cookie-及应用场景" class="headerlink" title="2、什么是 cookie 及应用场景"></a>2、什么是 cookie 及应用场景</h3><p><strong>cookie</strong>是某些网站为了辨别用户身份而存储在本地终端上的数据（通常经过加密）。</p><p>cookie 是服务端生成，客户端进行维护和存储。</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/20/1699babec3c4fcc4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>cookie 以键值对的形式存在。</p><p><strong>典型的应用场景</strong></p><ul><li>记住密码，下次自动登录</li><li>购物车功能</li><li>记录用户浏览数据，进行广告（商品）推荐</li></ul><h3 id="3、cookie-的原理"><a href="#3、cookie-的原理" class="headerlink" title="3、cookie 的原理"></a>3、cookie 的原理</h3><p><strong>cookie 原理</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/21/1699f22b7029ca14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>第一次访问网站时，浏览器发出请求，服务器响应请求后，会在响应头重添加一个 Set-Cookie 选项，将 cookie 放入响应请求中，</li><li>浏览器收到 Set-Cookie 选项后将它保存在本地</li><li>在浏览器第二次发起请求时，通过 cookie 请求头部将 cookie 信息发送给服务器，服务端会辨别用户身份。</li></ul><h2 id="二、session"><a href="#二、session" class="headerlink" title="二、session"></a>二、session</h2><p>session 代表着服务器和客户端一次会话的过程。session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序中的 web 页之间跳转时，存储在 session 对象中的变量将不会丢失，而是在整个会话中一直存在下去。当客户端关闭会话，或者 session 超时失效后会话结束。</p><h2 id="三、cookie-和-session-的关系"><a href="#三、cookie-和-session-的关系" class="headerlink" title="三、cookie 和 session 的关系"></a>三、cookie 和 session 的关系</h2><p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aafb5d90f398e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><ul><li>用户第一次请求服务器时，服务器根据用户提交的相关信息，创建对应的 session，请求返回时将此 session 的唯一标识符 sessionID 返回给浏览器，</li><li>浏览器收到 sessionID 后，将它保存在 cookie 中，同时 cookie 记录 sessionID 属于哪个域名</li><li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 cookie 信息，如果存在自动将 cookie 信息也发送给服务端，服务端会从 cookie 中获取 sessionID，再根据 sessionID 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作</li></ul><h2 id="四、cookie-和-session-的区别"><a href="#四、cookie-和-session-的区别" class="headerlink" title="四、cookie 和 session 的区别"></a>四、cookie 和 session 的区别</h2><ul><li><strong>存放位置不同</strong>，cookie 数据保存在客户端的浏览器上，session 数据保存在服务器上；</li><li><strong>存取方式不同</strong>，cookie 只能是字符串，session 可以是任意数据类型</li><li><strong>隐私策略不同</strong>，cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全问题应该使用 session</li><li><strong>存储大小不同</strong>，单个 cookie 保存的数据不能超过 4K，session 可存储数据远高于 4K</li><li><strong>有效期不同</strong>，cookie 可以较长时间保存，session 在客户端关闭或者 session 超时都会失效</li></ul><h2 id="五、localStorage、sessionStorage、cookie-的区别"><a href="#五、localStorage、sessionStorage、cookie-的区别" class="headerlink" title="五、localStorage、sessionStorage、cookie 的区别"></a>五、localStorage、sessionStorage、cookie 的区别</h2><ul><li><strong>http 请求</strong><ul><li>cookie 每次都会携带在 HTTP 头中，如果使用 cookie 保存数据过多会带来性能问题</li><li>sessionStorage 和 localStorage 不会把数据发送给服务器，仅在本地保存</li></ul></li><li><strong>存储数据大小</strong><ul><li>cookie 存储的数据不能超过 4K</li><li>sessionStorage 和 localStorage 可以达到 5M 或更大</li></ul></li><li><strong>数据存储有效期</strong><ul><li>cookie 在设置的 cookie 过期时间之前有效，如果没有设置，默认是关闭浏览器后失效</li><li>sessionStroage 仅在关闭当前窗口之前有效，关闭页面或浏览器后会被清除</li><li>localStorage 始终有效，除非被手动清除</li></ul></li><li><strong>易用性</strong><ul><li>cookie 需要自己封装，原生的 cookie 接口不太友好</li><li>localStorage 和 sessionStorage：原生接口可以接受，也可以再次封装来对 Object 和 Array 有更好的支持</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、cookie&quot;&gt;&lt;a href=&quot;#一、cookie&quot; class=&quot;headerlink&quot; title=&quot;一、cookie&quot;&gt;&lt;/a&gt;一、cookie&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="html" scheme="http://chajianyuanblog.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>总结：网络协议</title>
    <link href="http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2019-10-24T13:32:46.000Z</published>
    <updated>2020-09-23T03:28:47.896Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、HTTP-HTTPS"><a href="#一、HTTP-HTTPS" class="headerlink" title="一、HTTP/HTTPS"></a>一、HTTP/HTTPS</h2><p><a href="https://cjy1.github.io/2020/03/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Ahttp%E5%92%8Chttps/">参见总结：网络协议：http 和 https</a></p><h2 id="二、HTTP-状态码"><a href="#二、HTTP-状态码" class="headerlink" title="二、HTTP 状态码"></a>二、HTTP 状态码</h2><p><a href="https://cjy1.github.io/2019/10/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Ahttp%E7%8A%B6%E6%80%81%E7%A0%81/">参见总结：网络协议：http 状态码</a></p><h2 id="三、跨域问题"><a href="#三、跨域问题" class="headerlink" title="三、跨域问题"></a>三、跨域问题</h2><p><a href="https://cjy1.github.io/2019/10/19/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/">参见总结：网络协议：前端跨域</a></p><p><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">掘金</a></p><h2 id="四、TCP-和-UDP"><a href="#四、TCP-和-UDP" class="headerlink" title="四、TCP 和 UDP"></a>四、TCP 和 UDP</h2><p><strong>TCP 和 UDP 的区别</strong></p><ul><li>TCP（Transmission Control Protocal，传输控制协议）是基于连接的协议，也就是说，在正式发送数据前，必须和对方建立可靠的连接。一个 TCP 连接必须要经过 3 次对话才能建立起来。</li><li>UDP（User Datagram Protocal，用户数据报协议）是与 TCP 相对应的协议。它是面向非连接的协议。他不与对方建立连接，而是直接就把数据包发送过。UDP 适用于一次只传输少量数据，对可靠性要求不高的应用环境。</li></ul><h2 id="五、HTTP-请求方法"><a href="#五、HTTP-请求方法" class="headerlink" title="五、HTTP 请求方法"></a>五、HTTP 请求方法</h2><ul><li><p><code>GET</code>：发送一个请求来获得服务器上的某一资源</p></li><li><p><code>POST</code>：向 URL 指定的资源提交数据或附加新的数据</p></li><li><p><code>PUT</code>：跟 post 很像，也是向服务器提交资源，但是 put 指定了资源在服务器上的位置，而 post 没有</p></li><li><p><code>HEAD</code>：只请求页面的首部</p></li><li><p><code>DELETE</code>：删除服务器上的某资源</p></li><li><p><code>OPTIONS</code>：用于获取当前 URL 所支持的方法，如果请求成功，会有一个<code>Allow</code> 的头包含类似“<code>GET</code>，<code>POST</code>”这样的信息</p></li><li><p><code>TRACE</code>：被用于激发一个远程的，应用层的请求消息回路</p></li><li><p><code>CONNECT</code>：把请求连接转换到透明的<code>TCP/IP</code> 通道</p><h2 id="七、post-和-get-的区别"><a href="#七、post-和-get-的区别" class="headerlink" title="七、post 和 get 的区别"></a>七、post 和 get 的区别</h2><p><a href="https://cjy1.github.io/2019/10/20/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Apost%E5%92%8Cget%E7%9A%84%E5%8C%BA%E5%88%AB/">参见总结：网络协议：post 和 get 的区别</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、HTTP-HTTPS&quot;&gt;&lt;a href=&quot;#一、HTTP-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;一、HTTP/HTTPS&quot;&gt;&lt;/a&gt;一、H</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>总结：浏览器</title>
    <link href="http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2019-10-24T13:31:05.000Z</published>
    <updated>2020-02-28T08:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、一个-URL-从输入到显示的过程"><a href="#一、一个-URL-从输入到显示的过程" class="headerlink" title="一、一个 URL 从输入到显示的过程"></a>一、一个 URL 从输入到显示的过程</h2><p><a href="https://cjy1.github.io/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/">参见总结：浏览器：一个 URL 从输入到显示的过程</a></p><h2 id="二、重绘和回流"><a href="#二、重绘和回流" class="headerlink" title="二、重绘和回流"></a>二、重绘和回流</h2><p><a href="https://cjy1.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/">参见总结：浏览器：重绘和回流</a></p><h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><p><a href="https://juejin.im/post/5cb33660e51d456e811d2687">JavaScript 中的垃圾回收和内存泄漏</a></p><h2 id="四、浏览器兼容性"><a href="#四、浏览器兼容性" class="headerlink" title="四、浏览器兼容性"></a>四、浏览器兼容性</h2><p><a href="https://juejin.im/post/59a3f2fe6fb9a0249471cbb4">浏览器兼容问题</a></p><h2 id="五、浏览器缓存机制"><a href="#五、浏览器缓存机制" class="headerlink" title="五、浏览器缓存机制"></a>五、浏览器缓存机制</h2><p><a href="https://cjy1.github.io/2019/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">参见总结：浏览器：浏览器缓存机制</a></p><h2 id="六、事件机制"><a href="#六、事件机制" class="headerlink" title="六、事件机制"></a>六、事件机制</h2><p><a href="https://cjy1.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">参见总结：浏览器：事件机制</a></p><h2 id="七、事件循环机制"><a href="#七、事件循环机制" class="headerlink" title="七、事件循环机制"></a>七、事件循环机制</h2><p><a href="https://cjy1.github.io/2019/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEeventloop/">参见总结：浏览器：事件循环 Eventloop</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、一个-URL-从输入到显示的过程&quot;&gt;&lt;a href=&quot;#一、一个-URL-从输入到显示的过程&quot; class=&quot;headerlink&quot; title=&quot;一、一个 URL </summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>总结：javascript</title>
    <link href="http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ajavascript/"/>
    <id>http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ajavascript/</id>
    <published>2019-10-24T13:23:10.000Z</published>
    <updated>2020-03-12T10:00:05.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、数据类型及检测"><a href="#一、数据类型及检测" class="headerlink" title="一、数据类型及检测"></a>一、数据类型及检测</h2><p><a href="https://cjy1.github.io/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/">参见总结：JS：typeof、instanceof 以及 Object.prototyte.toString.call()</a></p><h2 id="二、原型与原型链、继承"><a href="#二、原型与原型链、继承" class="headerlink" title="二、原型与原型链、继承"></a>二、原型与原型链、继承</h2><p><a href="https://cjy1.github.io/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/">参见总结：JS：原型、原型链继承</a></p><h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><p>对于闭包，我的理解就是当某个函数 A 被调用时，这个函数 A 可以访问它定义时的作用域中的变量。</p><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在 JavaScript 中，函数即闭包，只有函数才会产生作用域。</p><p>闭包有 3 个特性：</p><ol><li>函数嵌套函数；</li><li>在函数内部可以引用外部的参数和变量；</li><li>参数和变量不会以垃圾回收机制回收。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">  let name &#x3D; &#39;zhangsan&#39;;</span><br><span class="line"></span><br><span class="line">  function b()&#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000006875662">JavaScript 闭包</a></p><h2 id="四、浅拷贝和深拷贝"><a href="#四、浅拷贝和深拷贝" class="headerlink" title="四、浅拷贝和深拷贝"></a>四、浅拷贝和深拷贝</h2><p><a href="https://cjy1.github.io/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">参见总结：JS：赋值、深拷贝和浅拷贝</a></p><h2 id="五、防抖和节流"><a href="#五、防抖和节流" class="headerlink" title="五、防抖和节流"></a>五、防抖和节流</h2><p>防抖：事件被触发 n 秒之后再执行回调，如果在这段时间之内又被触发，则重新计时。</p><p>节流：规定在单位时间之内只能触发一次，如果触发了多次只有一次生效。</p><p><a href="https://juejin.im/post/5b8de829f265da43623c4261">7 分钟理解 JS 的节流、防抖及使用场景</a></p><p><a href="https://juejin.im/post/5c87b54ce51d455f7943dddb#chapter-three-one">2019 面试准备 - JS 防抖与节流</a></p><h2 id="六、数组方法、数组去重"><a href="#六、数组方法、数组去重" class="headerlink" title="六、数组方法、数组去重"></a>六、数组方法、数组去重</h2><p><a href="https://cjy1.github.io/2019/10/14/JS%EF%BC%9A%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">参见总结：JS：数组方法</a></p><p><a href="https://cjy1.github.io/2019/10/16/JS%EF%BC%9A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/">参见总结：JS：数组去重</a></p><h2 id="七、作用域和作用域链"><a href="#七、作用域和作用域链" class="headerlink" title="七、作用域和作用域链"></a>七、作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去，也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p>ES6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域</p><ul><li><strong>全局作用域</strong>：在代码中任何地方都能访问到，比如最外层函数和在最外层函数外面定义的变量、所有未定义直接赋值的变量、所有 window 对象的属性</li><li><strong>函数作用域</strong> ：声明在函数里面的变量 ，只在固定的代码片段内能访问到</li><li>**块级作用域 **：可通过 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问，所声明的变量不会提升到代码块顶部，禁止重复声明，如在一个函数内部、在一个代码块（用一对花括号包裹）内部</li></ul><p><strong>块语句（大括号“{}”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，他们不会创建一个新的作用域。</strong></p><p><strong>作用域在定义时就确定，并且不会改变；执行上下文在运行时确定，随时可能改变。</strong></p><p><a href="https://juejin.im/post/5c8290455188257e5d0ec64f">深入理解 JavaScript 作用域和作用域链</a></p><h2 id="八、this-的指向和-new-的过程"><a href="#八、this-的指向和-new-的过程" class="headerlink" title="八、this 的指向和 new 的过程"></a>八、this 的指向和 new 的过程</h2><p><a href="https://cjy1.github.io/2019/10/15/ES6%EF%BC%9Athis/">参见总结：ES6：this</a></p><h2 id="九、JavaScript-有哪些垃圾回收机制？"><a href="#九、JavaScript-有哪些垃圾回收机制？" class="headerlink" title="九、JavaScript 有哪些垃圾回收机制？"></a>九、JavaScript 有哪些垃圾回收机制？</h2><ol><li><p>标记清除（mark and sweep）</p><p>这是 JavaScript 最常见的垃圾回收方式。当变量进入执行环境的时候,比如在函数中声明一个变量，垃圾回收器将其标记为”进入环境”。当变量离开环境的时候（函数执行结束），将其标记为“离开环境”。</p><p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量，以及被环境中变量所引用的变量（闭包）的标记。在完成这些之后仍然存在的标记就是要删除的变量。</p></li><li><p>引用计数</p><p>在低版本的 IE 中经常发生内存泄漏，很多时候就是因为它采用引用计数的方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就加 1,。如果该变量的值变成另外一个，则这个值得引用次数减 1，当这个值得引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问.因此，可以将它占用的空间回收，这样垃圾回收器会在运行的时候清理引用次数为 0 的值占用的空间。</p><p>在 IE 中虽然 JavaScript 对象通过标记清除方式进行垃圾回收，但是 BOM 与 DOM 对象是引用计数的方式回收垃圾的。也就是说，只要涉及 BOM 和 DOM，就会出现循环引用问题。</p></li></ol><h2 id="十、列举几种类型的-DOM-节点"><a href="#十、列举几种类型的-DOM-节点" class="headerlink" title="十、列举几种类型的 DOM 节点"></a>十、列举几种类型的 DOM 节点</h2><ul><li>整个文档是一个文档（Document）节点</li><li>每个 HTML 标签是一个元素（Element）节点</li><li>每一个 HTML 属性是一个属性（Attribute）节点</li><li>包含在 HTML 元素中的文本是文本（Text）节点</li></ul><h2 id="十一、谈谈-script-标签中-defer-和-async-属性的区别"><a href="#十一、谈谈-script-标签中-defer-和-async-属性的区别" class="headerlink" title="十一、谈谈 script 标签中 defer 和 async 属性的区别"></a>十一、谈谈 script 标签中 defer 和 async 属性的区别</h2><ol><li>defer 属性规定是否延迟执行脚本，直到页面加载为止。async 属性规定脚本一旦可用，就异步执行；</li><li>defer 并行加载 JavaScript 文件，会按照页面上 script 标签的顺序执行。async 并行加载 JavaScript 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行。</li></ol><h2 id="十二、encodeURI-和-decodeURI-的作用是什么？"><a href="#十二、encodeURI-和-decodeURI-的作用是什么？" class="headerlink" title="十二、encodeURI()和 decodeURI()的作用是什么？"></a>十二、encodeURI()和 decodeURI()的作用是什么？</h2><p>encodeURI()用于将 URL 转换为十六进制编码，而 decodeURI()用于将编码的 URL 转换成正常的 URL。</p><h2 id="十三、为什么不建议在-JavaScript-中使用-innerHTML？"><a href="#十三、为什么不建议在-JavaScript-中使用-innerHTML？" class="headerlink" title="十三、为什么不建议在 JavaScript 中使用 innerHTML？"></a>十三、为什么不建议在 JavaScript 中使用 innerHTML？</h2><p>通过 innerHTML 修改内容，每次都会刷新，因此很慢。在 innerHTML 中没有验证的机会，因此更容易在文档中插入错误代码，使网页不稳定。</p><h2 id="十四、在-DOM-操作中怎样创建、添加、移除、替换、插入和查找节点？"><a href="#十四、在-DOM-操作中怎样创建、添加、移除、替换、插入和查找节点？" class="headerlink" title="十四、在 DOM 操作中怎样创建、添加、移除、替换、插入和查找节点？"></a>十四、在 DOM 操作中怎样创建、添加、移除、替换、插入和查找节点？</h2><ol><li>创建节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment() &#x2F;&#x2F; 创建一个DOM片段</span><br><span class="line">createElement()  &#x2F;&#x2F;创建一个具体的元素</span><br><span class="line">createTextNode()  &#x2F;&#x2F;创建一个文本节点</span><br></pre></td></tr></table></figure><p>2.添加、移除、替换、插入节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">appendChild()</span><br><span class="line">removeChild()</span><br><span class="line">replaceChild()</span><br><span class="line">insertBefore()</span><br></pre></td></tr></table></figure><ol start="3"><li>查找节点</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getElementByTagName()  &#x2F;&#x2F;通过标签名称查找节点</span><br><span class="line">getElementByName()  &#x2F;&#x2F;通过元素的name属性查找节点（IE容错能力较强，会得到一个数组，其中包括id等于name值得节点）</span><br><span class="line">getElementById()  &#x2F;&#x2F;通过元素Id查找节点，具有唯一值</span><br></pre></td></tr></table></figure><h2 id="十五、null-和-undefined-的区别是什么？"><a href="#十五、null-和-undefined-的区别是什么？" class="headerlink" title="十五、null 和 undefined 的区别是什么？"></a>十五、null 和 undefined 的区别是什么？</h2><p>null 是一个表示“无”的对象，转为数值时为 0；undefined 是一个表示“无”的原始值，转为数值时为 NaN。</p><p>当声明的变量还未初始化时，变量的默认值为 undefined。</p><p>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p><p>undefined 表示“缺少值”，即此处应该有一个值，但是还没有定义，典型用法是：</p><ol><li>如果变量声明了，但是没有赋值，它就等于 undefined；</li><li>当调用函数时，如果没有提供应该提供的参数，该参数就等于 undefined；</li><li>如果对象没有赋值，该属性的值为 undefined；</li><li>当函数没有返回值时，默认返回 undefined。</li></ol><p>null 表示“没有对象”，即此处不应该有值，典型用法是：</p><ol><li>作为函数的参数，表示该函数的参数不是对象；</li><li>作为对象原型链的终点。</li></ol><h2 id="十六、JavaScript-延迟加载的方式有哪些？"><a href="#十六、JavaScript-延迟加载的方式有哪些？" class="headerlink" title="十六、JavaScript 延迟加载的方式有哪些？"></a>十六、JavaScript 延迟加载的方式有哪些？</h2><p>包括 defer 和 async，动态创建 DOM（创建 script，插入 DOM 中，加载完毕后回调，按需异步载入 JavaScript）。</p><h2 id="十七、call、apply、bind"><a href="#十七、call、apply、bind" class="headerlink" title="十七、call、apply、bind"></a>十七、call、apply、bind</h2><p><a href="https://cjy1.github.io/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/">参见总结：JS：call、apply、bind</a></p><h2 id="十八、哪些操作会造成内存泄漏？"><a href="#十八、哪些操作会造成内存泄漏？" class="headerlink" title="十八、哪些操作会造成内存泄漏？"></a>十八、哪些操作会造成内存泄漏？</h2><p>内存泄漏指不再拥有或需要任何对象（数据）之后，它们仍然存在于内存中。</p><p><strong>提示：</strong> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的唯一引用是循环的，那么该对象占用的内存立即被回收。</p><p>如果 settimeout 的第一个参数使用字符串而非函数，会引发内存泄漏。</p><p>闭包、控制台日志，循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）等会造成内存泄漏。</p><h2 id="十九、列举-IE-与-Firefox-的不同之处。"><a href="#十九、列举-IE-与-Firefox-的不同之处。" class="headerlink" title="十九、列举 IE 与 Firefox 的不同之处。"></a>十九、列举 IE 与 Firefox 的不同之处。</h2><p>不同之处如下。</p><ol><li>IE 支持 currentStyle，Firefox 使用 getComputStyle；</li><li>IE 使用 innerText，Firefox 使用 textContent;</li><li>在透明度过滤镜方面，IE 使用 filter:alpha(opacity = num); Firefox 使用-moz-opacity:num；</li><li>在事件方面，IE 使用 attachEvent；Firefox 使用 addEventListener；</li><li>对于鼠标位置：IE 使用 event.clientX；Firefox 使用 event.pageX；</li><li>IE 使用 event.srcElement；Firefox 使用 event.target。</li><li>要消除 list 圆点，IE 中仅需使 margin：0 即可达到最终效果，Firefox 中需要设置 margin：0，padding：0，list-style：none；</li><li>css 圆角：IE7 以下不支持圆角。</li></ol><h2 id="二十、如何实现异步编程？"><a href="#二十、如何实现异步编程？" class="headerlink" title="二十、如何实现异步编程？"></a>二十、如何实现异步编程？</h2><ol><li>通过回调函数，优点是简单、容易理解和部署；缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程混乱，而且每个任务只能指定一个回调函数。</li><li>通过事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化；缺点是整个程序都要变成事件驱动型，运行流程会变得恨不清晰。</li><li>采用发布/订阅方式，性质与“事件监听”类似，但是明显优于后者；</li><li>通过 Promise 对象实现，Promise 对象是 CommonJS 工作组提出的一种规范，旨在为异步编程提供统一接口。它的思想是，每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。</li></ol><h2 id="二十一、请解释一下-JavaScript-的同源策略。"><a href="#二十一、请解释一下-JavaScript-的同源策略。" class="headerlink" title="二十一、请解释一下 JavaScript 的同源策略。"></a>二十一、请解释一下 JavaScript 的同源策略。</h2><p>同源策略是客户端脚本（尤其是 JavaScript）的重要安全度量标准。它最早出自 Netscape Navigator 2.0，目的是防止某个文档或脚本从多个不同源装载。</p><p>这里的同源策略指的是协议、域名、端口相同。同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><h2 id="二十二、为什么要有同源限制？"><a href="#二十二、为什么要有同源限制？" class="headerlink" title="二十二、为什么要有同源限制？"></a>二十二、为什么要有同源限制？</h2><p>我们举例说明，比如一个黑客，他利用 Iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名、密码登录时，他的页面就可以通过 JavaScript 读取到你表单上 input 的内容，这样黑客就会轻松得到你的用户名和密码。</p><h2 id="二十三、map-filter-和-reduce"><a href="#二十三、map-filter-和-reduce" class="headerlink" title="二十三、map,filter 和 reduce"></a>二十三、map,filter 和 reduce</h2><p><a href="">参见总结：JS：map、filter、reduce</a></p><h2 id="二十四、前端模块化"><a href="#二十四、前端模块化" class="headerlink" title="二十四、前端模块化"></a>二十四、前端模块化</h2><p><a href="">参见总结：JS：前端模块化</a></p><h2 id="二十五、数组方法"><a href="#二十五、数组方法" class="headerlink" title="二十五、数组方法"></a>二十五、数组方法</h2><p><a href="">参见总结：JS：数组方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、数据类型及检测&quot;&gt;&lt;a href=&quot;#一、数据类型及检测&quot; class=&quot;headerlink&quot; title=&quot;一、数据类型及检测&quot;&gt;&lt;/a&gt;一、数据类型及检测&lt;/h</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>总结：html</title>
    <link href="http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ahtml/"/>
    <id>http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ahtml/</id>
    <published>2019-10-24T13:13:21.000Z</published>
    <updated>2020-09-23T03:28:57.732Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、HTML-语义化"><a href="#一、HTML-语义化" class="headerlink" title="一、HTML 语义化"></a>一、HTML 语义化</h2><h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>语义化的含义就是用正确的标签做正确的事情</p><h3 id="2、优势"><a href="#2、优势" class="headerlink" title="2、优势"></a>2、优势</h3><p>（1）便于对浏览器、搜索引擎解析</p><p>（2）便于盲人浏览网页</p><p>（3）便于阅读源代码的人对网站进行分开，维护和理解</p><h3 id="3、有哪些语义化的标签"><a href="#3、有哪些语义化的标签" class="headerlink" title="3、有哪些语义化的标签"></a>3、有哪些语义化的标签</h3><p>&lt; h1 &gt; - &lt; h6 &gt;、&lt; p &gt;、&lt; ul &gt;、&lt; ol &gt;、&lt; li&gt;、&lt; dl&gt;、&lt; dt&gt;、&lt; dd&gt;、&lt; em&gt;、&lt; strong&gt;、&lt; em&gt;、&lt; table&gt;、&lt; thead&gt;、&lt; tbody&gt;、&lt; td&gt;、&lt; th&gt;、&lt; caption&gt;等</p><h2 id="二、HTML5-新标签"><a href="#二、HTML5-新标签" class="headerlink" title="二、HTML5 新标签"></a>二、HTML5 新标签</h2><ul><li><code>header元素</code>：header 元素代表“网页”或“section”的页眉。</li><li><code>footer元素</code>：footer 元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。</li><li><code>hgroup元素</code>：</li><li><code>nav元素</code>：nav 元素代表页面的导航链接区域。用于定义页面的主要导航部分。</li><li><code>aside元素</code>：aside 元素被包含在 article 元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的 section）</li><li><code>section元素</code>：section 元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。section 通常还带标题，虽然 html5 中 section 会自动给标题 h1-h6 降级，但是最好手动给他们降级。</li><li><code>article元素</code>：article 元素最容易跟 section 和 div 容易混淆，其实 article 代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的 widget 小工具。（特殊的 section）除了它的内容，article 会有一个标题（通常会在 header 里），会有一个 footer 页脚。</li></ul><h2 id="三、常见浏览器及其内核"><a href="#三、常见浏览器及其内核" class="headerlink" title="三、常见浏览器及其内核"></a>三、常见浏览器及其内核</h2><table><thead><tr><th align="center"></th><th align="center">Chrome</th><th align="center">Firefox</th><th align="center">Safari</th><th align="center">IE</th><th align="center">Opera</th></tr></thead><tbody><tr><td align="center">内核</td><td align="center">Blink</td><td align="center">Gecko</td><td align="center">Webkit</td><td align="center">Trident</td><td align="center">Bink</td></tr></tbody></table><h2 id="四、-lt-script-gt-和-lt-link-gt-或者是-src-和-href-的区别"><a href="#四、-lt-script-gt-和-lt-link-gt-或者是-src-和-href-的区别" class="headerlink" title="四、 &lt; script &gt;和&lt; link &gt;或者是 src 和 href 的区别"></a>四、 &lt; script &gt;和&lt; link &gt;或者是 src 和 href 的区别</h2><ol><li>src 表示来源地址，用在 img、script、iframe 等元素上；</li><li>href 表示超文本引用，用在 link、a 等元素上；</li><li>src 的内容是页面必不可少的一部分，表示引入；而 href 的的内容与该页面有关联，表示引用；</li><li>src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系。</li></ol><h2 id="五、-lt-head-gt-中都有什么元素"><a href="#五、-lt-head-gt-中都有什么元素" class="headerlink" title="五、&lt; head &gt;中都有什么元素"></a>五、&lt; head &gt;中都有什么元素</h2><h3 id="1、-lt-base-gt"><a href="#1、-lt-base-gt" class="headerlink" title="1、&lt; base &gt;"></a>1、&lt; base &gt;</h3><p>为页面上的所有链接规定默认地址或默认目标</p><p>通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。</p><p>使用 &lt; base &gt; 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 &lt; a &gt;、&lt; img &gt;、&lt; link &gt;、&lt; form &gt; 标签中的 URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href&#x3D;&quot;http:&#x2F;&#x2F;www.w3school.com.cn&#x2F;i&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">&lt;base target&#x3D;&quot;_blank&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="2、-lt-link-gt"><a href="#2、-lt-link-gt" class="headerlink" title="2、&lt; link &gt;"></a>2、&lt; link &gt;</h3><p>定义文档与外部资源的关系，最常见的就是链接样式表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;theme.css&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h3 id="3、-lt-script-gt"><a href="#3、-lt-script-gt" class="headerlink" title="3、&lt; script &gt;"></a>3、&lt; script &gt;</h3><p>用于定义用户脚本，比如 JavaScript。script 元素既可以包含脚本语言，也可以通过 src 属性指向外部脚本文件。必须的 type 属性规定脚本的 MIME 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">document.write(&quot;Hello World!&quot;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="4、-lt-meta-gt"><a href="#4、-lt-meta-gt" class="headerlink" title="4、&lt; meta &gt;"></a>4、&lt; meta &gt;</h3><p>可提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词。定义了与文档相关联的名称/值对。</p><p><code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML,ASP,PHP,SQL&quot;&gt;</code></p><h3 id="5、-lt-style-gt"><a href="#5、-lt-style-gt" class="headerlink" title="5、&lt; style &gt;"></a>5、&lt; style &gt;</h3><p>用于为 html 文档定义样式信息。type 属性是必须的，定义 style 元素的内容，唯一可能的值是“text/css”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">h1 &#123;color:red&#125;</span><br><span class="line">p &#123;color:blue&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h3 id="6、-lt-title-gt"><a href="#6、-lt-title-gt" class="headerlink" title="6、&lt; title &gt;"></a>6、&lt; title &gt;</h3><p>定义文档的标题，通常是现实在浏览器窗口的标题栏或者是状态栏上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;XHTML Tag Reference&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure><h2 id="六、本地存储"><a href="#六、本地存储" class="headerlink" title="六、本地存储"></a>六、本地存储</h2><p><a href="https://cjy1.github.io/2019/10/26/cookie%E3%80%81sessionStorage%E3%80%81localStorage%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/">参见总结：cookie、session、sessionStorage、localStorage</a></p><h2 id="七、websocket"><a href="#七、websocket" class="headerlink" title="七、websocket"></a>七、websocket</h2><p><a href="https://cjy1.github.io/2019/10/26/webSocket%E5%AD%A6%E4%B9%A0/">参见总结：webSocket 学习</a></p><h2 id="八、W3C-标准"><a href="#八、W3C-标准" class="headerlink" title="八、W3C 标准"></a>八、W3C 标准</h2><p>w3c 标准不是某一个标准，而是一系列标准的集合，网页主要由三部分组成：结构（structure）、表现（Presentation）、行为（behavior）</p><h3 id="1、结构标准语言"><a href="#1、结构标准语言" class="headerlink" title="1、结构标准语言"></a>1、结构标准语言</h3><h4 id="1-1-可扩展标记语言（XML）"><a href="#1-1-可扩展标记语言（XML）" class="headerlink" title="1.1 可扩展标记语言（XML）"></a>1.1 可扩展标记语言（XML）</h4><p>和 HTML 一样，XML 同样来源于标准通用标记语言，可扩展标记语言和标准通用标记语言都是能定义其他语言的语言。XML 最初设计的目的是弥补 HTML 的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。</p><h4 id="1-2-可扩展超文本标记语言（XHTML）"><a href="#1-2-可扩展超文本标记语言（XHTML）" class="headerlink" title="1.2 可扩展超文本标记语言（XHTML）"></a>1.2 可扩展超文本标记语言（XHTML）</h4><p><strong>HTML 和 XHTML 的共同点</strong></p><ul><li>所有的标记都必须有一个对应的结束标记</li><li>所有的标签的元素和属性的名字都必须使用小写</li><li>所有的 XML 标记都必须合理嵌套</li><li>所有的属性都必须用“ ”引起来</li><li>所有的“&lt;”和“&amp;”特殊符号都用编码表示</li><li>给所有属性赋一个值</li><li>不要在注释内容中使用“–”</li><li>图片必须有说明文字</li></ul><p><strong>HTML 和 XHTML 的区别</strong></p><ul><li>HTML 是一种基于 web 网页的设计语言，XHTML 是一种基于 XML、语法严格、标准的设计语言</li><li>XHTML 元素必须正确的嵌套，元素必须关闭，标签必须小写，必须有根元素；HTML 没有这些限制</li></ul><h3 id="2、表现标准语言"><a href="#2、表现标准语言" class="headerlink" title="2、表现标准语言"></a>2、表现标准语言</h3><h4 id="2-1-层叠样式表（css）"><a href="#2-1-层叠样式表（css）" class="headerlink" title="2.1 层叠样式表（css）"></a>2.1 层叠样式表（css）</h4><p>万维网联盟创建 CSS 标准的目的是以 CSS 取代 HTML 表格式布局、帧和其他表现的语言。纯 CSS 布局与结构式 XHTML 相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。</p><h3 id="3、行为标准"><a href="#3、行为标准" class="headerlink" title="3、行为标准"></a>3、行为标准</h3><h4 id="3-1-文档对象模型（DOM）"><a href="#3-1-文档对象模型（DOM）" class="headerlink" title="3.1 文档对象模型（DOM）"></a>3.1 文档对象模型（DOM）</h4><p>根据 W3C DOM 规范，DOM 是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM 解决了 Netscaped 的 Javascript 和 Microsoft 的 Jscript 之间的冲突，给予 web 设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。</p><h4 id="3-2-ECMAScript"><a href="#3-2-ECMAScript" class="headerlink" title="3.2 ECMAScript"></a>3.2 ECMAScript</h4><p>ECMAScript 是 ECMA(European Computer Manufacturers Association)制定的标准脚本语言（JAVAScript）。</p><h2 id="九、img-标签上的-title-和-alt-属性的区别"><a href="#九、img-标签上的-title-和-alt-属性的区别" class="headerlink" title="九、img 标签上的 title 和 alt 属性的区别"></a>九、img 标签上的 title 和 alt 属性的区别</h2><ul><li>title 的功能是为元素提供标题信息，即当光标悬浮在标签上后显示的信息</li><li>alt 的功能是图片的替换文案，即当图片不能正常显示的时（如加载失败），用文字代替</li></ul><h2 id="十、空元素"><a href="#十、空元素" class="headerlink" title="十、空元素"></a>十、空元素</h2><p>空元素也就是单标签元素：&lt; br &gt;、&lt; hr &gt;、&lt; img &gt;、&lt; input &gt;、&lt; link &gt;、&lt; meta &gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、HTML-语义化&quot;&gt;&lt;a href=&quot;#一、HTML-语义化&quot; class=&quot;headerlink&quot; title=&quot;一、HTML 语义化&quot;&gt;&lt;/a&gt;一、HTML 语义</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>总结：vue</title>
    <link href="http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Avue/"/>
    <id>http://chajianyuanblog.com/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Avue/</id>
    <published>2019-10-24T02:52:09.000Z</published>
    <updated>2020-02-22T07:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、Vue-生命周期"><a href="#一、Vue-生命周期" class="headerlink" title="一、Vue 生命周期"></a>一、Vue 生命周期</h2><p><a href="https://cjy1.github.io/2019/10/19/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">参见总结：vue：生命周期</a></p><h2 id="二、Vue-双向数据绑定原理"><a href="#二、Vue-双向数据绑定原理" class="headerlink" title="二、Vue 双向数据绑定原理"></a>二、Vue 双向数据绑定原理</h2><p><a href="https://cjy1.github.io/2019/10/19/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/">参见总结：vue：双向绑定</a></p><h2 id="三、v-show-和-v-if-的区别"><a href="#三、v-show-和-v-if-的区别" class="headerlink" title="三、v-show 和 v-if 的区别"></a>三、v-show 和 v-if 的区别</h2><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h2 id="四、MVVM"><a href="#四、MVVM" class="headerlink" title="四、MVVM"></a>四、MVVM</h2><p><a href="https://juejin.im/post/5af8eb55f265da0b814ba766">掘金：看完这篇关于 MVVM 的文章，面试通过率提升了 80%</a></p><h2 id="五、虚拟-DOM"><a href="#五、虚拟-DOM" class="headerlink" title="五、虚拟 DOM"></a>五、虚拟 DOM</h2><p><a href="https://juejin.im/post/5d12c931f265da1bb2773fcc">掘金：揭秘 Vue 中的 Virtual Dom</a></p><h2 id="六、key"><a href="#六、key" class="headerlink" title="六、key"></a>六、key</h2><p><img src="https://user-gold-cdn.xitu.io/2019/10/31/16e1f60b7d343768?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br><img src="https://user-gold-cdn.xitu.io/2019/10/31/16e1f6105886daf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br>key 的作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。</p><ul><li>key 会用在虚拟 DOM 算法（diff 算法）中，用来辨别新旧节点；</li><li>不带 key 的时候会最大限度减少元素的变动，尽可能用相同的元素（就地复用）；</li><li>带 key 的时候，会基于相同的 key 来进行排列（相同的复用）；</li><li>带 key 还能触发过渡效果，以及触发组件的生命周期。</li></ul><h2 id="七、nextTick"><a href="#七、nextTick" class="headerlink" title="七、nextTick"></a>七、nextTick</h2><p><a href="https://juejin.im/post/5a6fdb846fb9a01cc0268618">掘金：简单理解 Vue 中的 nextTick</a></p><h2 id="八、template-编译"><a href="#八、template-编译" class="headerlink" title="八、template 编译"></a>八、template 编译</h2><p>详情步骤：首先，通过 compile 编译器把 template 编译成 AST 语法树（abstractsyntaxtree 即源代码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option。</p><p>然后，AST 会经过 generate（将 AST 语法树转化成 renderfuntion 字符串的过程）得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点，里面有（标签名、子节点、文本等等）</p><h2 id="九、组件间通讯"><a href="#九、组件间通讯" class="headerlink" title="九、组件间通讯"></a>九、组件间通讯</h2><p><a href="https://juejin.im/post/5cde0b43f265da03867e78d3">掘金：Vue 组件间通信六种方式（完整版）</a></p><h2 id="十、父子组件生命周期"><a href="#十、父子组件生命周期" class="headerlink" title="十、父子组件生命周期"></a>十、父子组件生命周期</h2><h3 id="1、加载渲染过程"><a href="#1、加载渲染过程" class="headerlink" title="1、加载渲染过程"></a>1、加载渲染过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</span><br></pre></td></tr></table></figure><h3 id="2、子组件更新过程"><a href="#2、子组件更新过程" class="headerlink" title="2、子组件更新过程"></a>2、子组件更新过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</span><br></pre></td></tr></table></figure><h3 id="3、父组件更新过程"><a href="#3、父组件更新过程" class="headerlink" title="3、父组件更新过程"></a>3、父组件更新过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate-&gt;父updated</span><br></pre></td></tr></table></figure><h3 id="4、销毁过程"><a href="#4、销毁过程" class="headerlink" title="4、销毁过程"></a>4、销毁过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</span><br></pre></td></tr></table></figure><h2 id="十一、keep-alive"><a href="#十一、keep-alive" class="headerlink" title="十一、keep-alive"></a>十一、keep-alive</h2><p>如果想把切换出去的组件保留在内存中，并保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令</p><p><code>&lt;component:is=&#39;curremtView&#39; keep-alive&gt;&lt;/component&gt;</code></p><h2 id="十二、Vuex"><a href="#十二、Vuex" class="headerlink" title="十二、Vuex"></a>十二、Vuex</h2><p><a href="https://juejin.im/post/5bbe15dcf265da0a867c57bd">掘金：从头开始学习 Vuex</a></p><p>vuex 是一个状态管理容器(你也可以理解为类似于全局变量),数据的流向是是单向数据流</p><table><thead><tr><th>vuex</th><th>vue</th></tr></thead><tbody><tr><td>state</td><td>data</td></tr><tr><td>getters</td><td>computed</td></tr><tr><td>mutations</td><td>methods（同步操作）</td></tr><tr><td>actions</td><td>methods（异步操作</td></tr></tbody></table><h2 id="十三、vue版本之间的区别"><a href="#十三、vue版本之间的区别" class="headerlink" title="十三、vue版本之间的区别"></a>十三、vue版本之间的区别</h2><p><a href="">参见总结：vue：vue版本之间的区别</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、Vue-生命周期&quot;&gt;&lt;a href=&quot;#一、Vue-生命周期&quot; class=&quot;headerlink&quot; title=&quot;一、Vue 生命周期&quot;&gt;&lt;/a&gt;一、Vue 生命周</summary>
      
    
    
    
    <category term="技术" scheme="http://chajianyuanblog.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://chajianyuanblog.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
