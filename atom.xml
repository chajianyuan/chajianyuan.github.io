<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>查见原的博客</title>
  
  <subtitle>越努力，越幸运</subtitle>
  <link href="https://chajianyuan.github.io/atom.xml" rel="self"/>
  
  <link href="https://chajianyuan.github.io/"/>
  <updated>2021-03-08T08:43:19.997Z</updated>
  <id>https://chajianyuan.github.io/</id>
  
  <author>
    <name>chajianyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>elixir：基础数据结构</title>
    <link href="https://chajianyuan.github.io/2021/03/01/elixir%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://chajianyuan.github.io/2021/03/01/elixir%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-03-01T03:46:34.000Z</published>
    <updated>2021-03-08T08:43:19.997Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.draveness.me/2019-02-13-elixir-programming-language.png"></p><a id="more"></a><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>简单介绍下<code>elixir</code>，<code>elixir</code>官方将其定义成了【一个用于构建可伸缩、可维护应用的动态、函数式编程语言】、它运行在Erlang的虚拟机上，能够充分利用虚拟机的优点运行低延时、高容错的分布式系统。</p><h4 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h4><p>函数式编程其实是一种编程范式，它强调程序执行的结果而不是过程。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>即所有数据结构一旦被初始化就不能被改变。</p><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>这个特性不仅能够对数据结构进行解构，还能够帮助根据函数的入参对方法逻辑进行拆分使代码更加清晰。</p><h4 id="面向并发"><a href="#面向并发" class="headerlink" title="面向并发"></a>面向并发</h4><h3 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>            =&gt; <span class="built_in">int</span>eger</span><br><span class="line"><span class="number">0x1F</span>         =&gt; <span class="built_in">int</span>eger</span><br><span class="line"><span class="number">1.0</span>          =&gt; <span class="built_in">float</span></span><br><span class="line">:atom        =&gt; atom / symbol</span><br><span class="line"><span class="string">&quot;elixir&quot;</span>     =&gt; <span class="built_in">string</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]    =&gt; list</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;    =&gt; tuple</span><br></pre></td></tr></table></figure><h4 id="1-基础运算"><a href="#1-基础运算" class="headerlink" title="1. 基础运算"></a>1. 基础运算</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>+ <span class="number">2</span>       =&gt; <span class="number">3</span></span><br><span class="line"><span class="symbol">5 </span>* <span class="number">5</span>       =&gt; <span class="number">25</span></span><br><span class="line"><span class="symbol">10 </span>/ <span class="number">2</span>      =&gt; <span class="number">5.0</span></span><br></pre></td></tr></table></figure><p><code>elixir</code>同时支持二进制、八进制和十六进制的数字</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1F</span>         =&gt; <span class="number">31</span> </span><br><span class="line"><span class="number">0o777</span>        =&gt; <span class="number">511</span></span><br><span class="line"><span class="number">0b1010</span>       =&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="2-布尔值"><a href="#2-布尔值" class="headerlink" title="2. 布尔值"></a>2. 布尔值</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">is_boolean</span><span class="params">(true)</span></span>   =&gt; true</span><br><span class="line"><span class="function"><span class="title">is_boolean</span><span class="params">(<span class="number">1</span>)</span></span>      =&gt; false</span><br></pre></td></tr></table></figure><blockquote><p>可以使用<code>is_integer/1</code>检查参数是否是整数<br>可以使用<code>is_float/1</code>检查参数是否为浮点数<br>可以使用<code>is_number/1</code>检查参数是否为上面两个中的一个</p></blockquote><h4 id="3-原子"><a href="#3-原子" class="headerlink" title="3. 原子"></a>3. 原子</h4><p>也就是<code>Symbols</code>，代表以名字为值的恒量</p><h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4. 字符串"></a>4. 字符串</h4><p>字符串必须用双引号来表达，并且用UTF-8编码</p><p>（1）<code>IO.puts/1</code>来打印字符串</p><p>（2）字符串在底层是用二进制，<code>is_binary</code></p><p>（3）<code>byte_size</code>计算字符串的字节数</p><p>（4）<code>String.length/1</code>计算字符串长度</p><blockquote><p>⚠️ 单引号和双引号是不一样的</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> == <span class="string">&quot;hello&quot;</span>  =&gt; <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="5-匿名函数"><a href="#5-匿名函数" class="headerlink" title="5. 匿名函数"></a>5. 匿名函数</h4><p>函数用关键值<code>fn</code>和<code>end</code>来表达</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> = <span class="meta">fn</span> a, <span class="keyword">b</span> -&gt; a + <span class="keyword">b</span> <span class="meta">end</span></span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 当调用匿名函数时，在指向这个匿名函数的变量名和圆括号之间需要有一个点（.）<code>add.(1, 2)</code></p></blockquote><blockquote><p>❕在一个函数内部的变量赋值，并不影响函数外部的环境</p></blockquote><p>（1）<code>is_function/1</code>检验是否为函数</p><p>（2）<code>if_funciton/2</code>检查一个函数接受的函数数量</p><h4 id="6-（链接）列表"><a href="#6-（链接）列表" class="headerlink" title="6. （链接）列表"></a>6. （链接）列表</h4><p>用方括号标识一个列表，内部的类型是随意的</p><p>使用函数<code>++2</code>，<code>--2</code>进行合并或相异操作</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="string">++</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]                          <span class="string">=&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">false</span>, <span class="number">3</span>, <span class="literal">true</span>] <span class="string">--</span> [<span class="literal">true</span>, <span class="literal">false</span>]   <span class="string">=&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure><p>（1）<code>hd/1</code> 获得列表的第一个元素</p><p>（2）<code>tl</code> 获得除第一个元素剩余的元素</p><blockquote><p>⚠️ 获取一个空列表的头会导致一个错误 <code>(ArgumentError) argument error</code></p></blockquote><h4 id="7-元组"><a href="#7-元组" class="headerlink" title="7. 元组"></a>7. 元组</h4><p>元组用花括号表示</p><p>（1） <code>elem/2</code>获取元组中的某个元素</p><p>（2）<code>set_elem/3</code>可以把一个元素放在一个特定的索引上（返回一个新元组，不会破坏原元组）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/2019-02-13-elixir-programming-language.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="elixir" scheme="https://chajianyuan.github.io/tags/elixir/"/>
    
  </entry>
  
  <entry>
    <title>每日一道算法打卡：找到所有数组中消失的数字</title>
    <link href="https://chajianyuan.github.io/2021/02/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1%EF%BC%9A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://chajianyuan.github.io/2021/02/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E6%89%93%E5%8D%A1%EF%BC%9A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2021-02-13T03:28:35.000Z</published>
    <updated>2021-02-13T08:42:13.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong><br>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><a id="more"></a><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a></p><p><strong>解题思路：</strong></p><p>暴力法，遍历，但是费时</p><p><strong>代码展示：</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">var</span> findDisappearedNumbers = function(nums) &#123;</span><br><span class="line">    const len = nums.<span class="built_in">length</span>;</span><br><span class="line">    const res = [];</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">num</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.includes(<span class="built_in">num</span>)) &#123;</span><br><span class="line">            res.<span class="built_in">push</span>(<span class="built_in">num</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">num</span> = <span class="built_in">num</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;br&gt;给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://chajianyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://chajianyuan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>book: 阅读清单</title>
    <link href="https://chajianyuan.github.io/2021/02/09/book%EF%BC%9A%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"/>
    <id>https://chajianyuan.github.io/2021/02/09/book%EF%BC%9A%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/</id>
    <published>2021-02-09T02:35:19.000Z</published>
    <updated>2021-03-05T00:18:01.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1294118-7d84c47d8294637c.jpg"></p><a id="more"></a><h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><ol><li>css世界（2月9日）</li><li><a href="https://mp.weixin.qq.com/s/8j2z3uOaVWADLf5FD_BF3g">Javascript代码整洁之道</a> (3月5日)</li></ol><!-- 2. 数据结构与算法之美（3月1日） -->]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1294118-7d84c47d8294637c.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://chajianyuan.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>css：实现文字自动滚动（animation属性和@keyframes规则）</title>
    <link href="https://chajianyuan.github.io/2021/01/08/css%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%EF%BC%88animation%E5%B1%9E%E6%80%A7%E5%92%8C@keyframes%E8%A7%84%E5%88%99%EF%BC%89/"/>
    <id>https://chajianyuan.github.io/2021/01/08/css%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%EF%BC%88animation%E5%B1%9E%E6%80%A7%E5%92%8C@keyframes%E8%A7%84%E5%88%99%EF%BC%89/</id>
    <published>2021-01-08T07:48:20.000Z</published>
    <updated>2021-02-10T10:48:48.112Z</updated>
    
    <content type="html"><![CDATA[<p>使用css的animation属性和@keyframes规则，实现中奖信息的滚动播报</p><p>要创建 css3 动画，需要了解@keyframes 规则</p><a id="more"></a><ul><li>@keyframes 规则是创建动画</li><li>@keyframes 规则内指定一个 CSS 样式动画将逐步从目前的样式更改为新的样式</li></ul><p>当在 <strong>@keyframes</strong> 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。</p><p>指定至少这两个 CSS3 的动画属性绑定向一个选择器：</p><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>keyframes</td><td>规定动画。</td></tr><tr><td>animation</td><td>所有动画属性的简写属性，除了 animation-play-state 属性。</td></tr><tr><td>animation-name</td><td>规定 @keyframes 动画的名称。</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线。默认是 “ease”。</td></tr><tr><td>animation-fill-mode</td><td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td></tr><tr><td>animation-delay</td><td>规定动画何时开始。默认是 0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数。默认是 1。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是 “running”。</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">div&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line"><span class="attribute">position</span>:relative;</span><br><span class="line"><span class="attribute">animation-name</span>:myfirst;</span><br><span class="line"><span class="attribute">animation-duration</span>:<span class="number">5s</span>;</span><br><span class="line"><span class="attribute">animation-timing-function</span>:linear;</span><br><span class="line"><span class="attribute">animation-delay</span>:<span class="number">2s</span>;</span><br><span class="line"><span class="attribute">animation-iteration-count</span>:infinite;</span><br><span class="line"><span class="attribute">animation-direction</span>:alternate;</span><br><span class="line"><span class="attribute">animation-play-state</span>:running;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes myfirst</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0%</span>   &#123;<span class="attribute">background</span>:red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="number">25%</span>  &#123;<span class="attribute">background</span>:yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="number">50%</span>  &#123;<span class="attribute">background</span>:blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line"><span class="number">75%</span>  &#123;<span class="attribute">background</span>:green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line"><span class="number">100%</span> &#123;<span class="attribute">background</span>:red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="animation-和-transition-的异同"><a href="#animation-和-transition-的异同" class="headerlink" title="animation 和 transition 的异同"></a>animation 和 transition 的异同</h3><p><strong>相同：</strong> 功能相同，都是通过改变元素的属性值来实现动画效果的。</p><p><strong>不同：</strong> transition 只能用指定属性的开始值和结束值，然后在这两个属性值之间使用平滑过渡的方式实现动画效果，因此不能实现比较复杂的动画效果；animation 通过定义多个关键帧，以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果。</p><p>以react.js为例</p><p>JSX部分</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;prize-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;rowup&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">      winners.<span class="keyword">map</span>(<span class="type">item</span> =&gt; &lt;div<span class="built_in"> key</span>=&#123;<span class="type">item</span>.nick&#125;</span><span class="xml"> className=&quot;winner-info&quot;&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">&quot;prize-img&quot;</span> <span class="attr">src</span>=</span></span><span class="xquery">&#123;<span class="type">item</span>.headerpic ? <span class="type">item</span>.headerpic : defaultAvatar&#125;</span><span class="xml"><span class="tag"> /&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xquery">&#123;<span class="type">item</span>.nick&#125;</span><span class="xml">已获得</span><span class="xquery">&#123;<span class="type">item</span>.price&#125;</span><span class="xml">元试用资格</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml">)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>CSS部分</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.prize-info</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">#FFFFFF</span>, .<span class="number">19</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.63rem</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">9.5rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">15rem</span> .<span class="number">7rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">55rem</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="selector-class">.winner-info</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: .<span class="number">2rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.prize-img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: .<span class="number">7rem</span>;</span><br><span class="line">    <span class="attribute">height</span>: .<span class="number">7rem</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: .<span class="number">15rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.prize-info</span> <span class="selector-class">.rowup</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: .<span class="number">85rem</span>;</span><br><span class="line">  -webkit-<span class="attribute">animation</span>: <span class="number">10s</span> rowup linear infinite normal;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">10s</span> rowup linear infinite normal;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> rowup &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">      -webkit-<span class="attribute">transform</span>: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="attribute">transform</span>: translate3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">      -webkit-<span class="attribute">transform</span>: translate3d(<span class="number">0</span>, -<span class="number">8em</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="attribute">transform</span>: translate3d(<span class="number">0</span>, -<span class="number">8rem</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>待更～（后续会记录使用websocket时时更新数据）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用css的animation属性和@keyframes规则，实现中奖信息的滚动播报&lt;/p&gt;
&lt;p&gt;要创建 css3 动画，需要了解@keyframes 规则&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JS：字符串方法</title>
    <link href="https://chajianyuan.github.io/2020/11/11/JS%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/"/>
    <id>https://chajianyuan.github.io/2020/11/11/JS%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95/</id>
    <published>2020-11-11T07:59:47.000Z</published>
    <updated>2021-02-10T10:50:44.115Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let str</span> = <span class="string">&#x27;My name is Lily&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="一、提取字符串方法"><a href="#一、提取字符串方法" class="headerlink" title="一、提取字符串方法"></a>一、提取字符串方法</h3><h4 id="1-charAt"><a href="#1-charAt" class="headerlink" title="1. charAt()"></a>1. charAt()</h4><p><code>charAt</code> 获取字符串的某个字符。</p><a id="more"></a><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(<span class="number">3</span>)  <span class="regexp">//</span> <span class="string">&quot;n&quot;</span></span><br></pre></td></tr></table></figure><p>还有一种方式是把字符串当成一个类似数组的对象，对其中的每个字符进行索引。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">3</span>]  <span class="regexp">//</span> <span class="string">&quot;n&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-charCodeAt"><a href="#2-charCodeAt" class="headerlink" title="2. charCodeAt()"></a>2. charCodeAt()</h4><p><code>charCodeAt()</code>方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元。</p><p><strong>返回值：</strong> 指定index处字符的UTF-16代码单元值的一个数字；如果index超出范围，<code>charCodeAt()</code>返回NaN。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">char</span><span class="constructor">CodeAt(3)</span>  <span class="comment">// 110</span></span><br></pre></td></tr></table></figure><h3 id="二、提取部分字符串"><a href="#二、提取部分字符串" class="headerlink" title="二、提取部分字符串"></a>二、提取部分字符串</h3><h4 id="3-slice"><a href="#3-slice" class="headerlink" title="3. slice"></a>3. slice</h4><p><code>slice()</code>提取字符串的某个部分并在新字符串中返回被提取的部分</p><p>该方法设置两个参数：起始索引和终止索引</p><p>如果某个参数为负数，则从字符串的结尾开始计数</p><p>如果省略第二个参数，则裁剪字符串的剩余部分</p><h4 id="4-subString"><a href="#4-subString" class="headerlink" title="4. subString"></a>4. subString</h4><p><code>subString()</code>类似于<code>slice()</code></p><p>不同之处在于<code>subString()</code>不支持参数为负数</p><h4 id="5-subStr"><a href="#5-subStr" class="headerlink" title="5. subStr"></a>5. subStr</h4><p><code>subStr()</code>类似于<code>slice()</code></p><p>不同之处在于<code>subStr</code>第二个参数规定被提取部分的长度</p><p>如果第一个参数为负数，则从字符串的末尾开始计算</p><h3 id="三、替换字符串内容"><a href="#三、替换字符串内容" class="headerlink" title="三、替换字符串内容"></a>三、替换字符串内容</h3><h4 id="6-replace"><a href="#6-replace" class="headerlink" title="6. replace"></a>6. replace</h4><p><code>replace()</code>方法用一个值替换在字符串中指定的值</p><p><code>replace()</code>方法不会改变调用它的字符串，返回一个新字符串</p><p><code>replace()</code>默认只替换首个匹配</p><p><code>replace()</code>对大小写敏感</p><p>如需执行大小写不敏感的替换，则使用正则表达式<code>/i</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;Please visit Microsoft!&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> n = str.replace(<span class="regexp">/MICROSOFT/i</span>, <span class="string">&quot;W3School&quot;</span>);</span><br></pre></td></tr></table></figure><p>如需替换所有匹配，则使用正则表达式的<code>g</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;Please visit Microsoft and Microsoft!&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> n = str.replace(<span class="regexp">/Microsoft/g</span>, <span class="string">&quot;W3School&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="四、转换为大写和小写"><a href="#四、转换为大写和小写" class="headerlink" title="四、转换为大写和小写"></a>四、转换为大写和小写</h3><h4 id="7-toUpperCase"><a href="#7-toUpperCase" class="headerlink" title="7. toUpperCase"></a>7. toUpperCase</h4><p><code>toUpperCase()</code>把字符串转换为大写</p><h4 id="8-toLowerCase"><a href="#8-toLowerCase" class="headerlink" title="8. toLowerCase"></a>8. toLowerCase</h4><p><code>toLowerCase()</code>把字符串转换为小写</p><h3 id="五、字符串转数组"><a href="#五、字符串转数组" class="headerlink" title="五、字符串转数组"></a>五、字符串转数组</h3><h4 id="9-split"><a href="#9-split" class="headerlink" title="9.split"></a>9.split</h4><h3 id="六、查找字符串中的字符串"><a href="#六、查找字符串中的字符串" class="headerlink" title="六、查找字符串中的字符串"></a>六、查找字符串中的字符串</h3><h4 id="10-indexOf"><a href="#10-indexOf" class="headerlink" title="10. indexOf()"></a>10. indexOf()</h4><p><code>indexOf()</code> 方法返回调用它的String对象中第一次出现的指定值的索引，从fromIndex开始查找，如果没有找到该值，返回-1。</p><p><strong>参数：</strong></p><ul><li>searchValue：要被查找的字符串值，如果<code>searchValue</code>是空字符串，则返回<code>fromIndex</code></li><li>fromIndex：要开始查找的位置（数字），默认值是0</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(<span class="string">&#x27;a&#x27;</span>)  <span class="regexp">//</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="11-lastIndexOf"><a href="#11-lastIndexOf" class="headerlink" title="11. lastIndexOf()"></a>11. lastIndexOf()</h4><p><code>lastIndexOf()</code>方法返回调用它的String对象中的指定值最后一次出校的索引，在一个字符串中的指定位置处从后向前搜索，如果没有找到则返回-1。</p><p><strong>参数：</strong></p><ul><li>searchValue：要被查找的字符串值，如果<code>searchValue</code>是空字符串，则返回<code>fromIndex</code></li><li>fromIndex：要开始查找的位置（数字），默认值是<code>+Infinity</code>，如果<code>fromIndex &gt;= str.length</code>，则会搜索整个字符串；如果<code>fromIndex &lt; 0</code>，则等同于<code>fromIndex == 0</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.lastIndexOf(<span class="string">&#x27;a&#x27;</span>)  <span class="regexp">//</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="12-search"><a href="#12-search" class="headerlink" title="12. search"></a>12. search</h4><p><code>search()</code>方法搜索特定值的字符串，并返回匹配的位置</p><p>⚠️ 注意：indexOf()和search()方法的区别在于</p><ul><li>search()方法无法设置第二个参数</li><li>indexOf()方法无法设置更强大的搜索值（正则表达式）</li></ul><h3 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h3><h4 id="13-includes"><a href="#13-includes" class="headerlink" title="13. includes()"></a>13. includes()</h4><p><code>includes()</code> 方法用于判断一个字符串是否包含在另一个字符串中，根绝结果返回true或false。</p><p><strong>返回值：</strong> true或false</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.includes(<span class="string">&#x27;abc&#x27;</span>)  <span class="regexp">//</span> false</span><br></pre></td></tr></table></figure><h4 id="14-concat"><a href="#14-concat" class="headerlink" title="14. concat()"></a>14. concat()</h4><p><code>concat()</code>方法将一个或多个字符串与原字符串链接合并，形成一个新的字符串并返回。</p><p><strong>返回值：</strong> 一个新的字符串</p><p><strong>不会改变原字符串</strong></p><p><strong>性能：</strong> 强烈建议使用赋值操作符（+， +=）代替concat方法。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.concat(<span class="string">&#x27;, too&#x27;</span>)  <span class="regexp">//</span> <span class="string">&quot;My name is Lily, too&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.concat(&#123;&#125;)        <span class="regexp">//</span> <span class="string">&quot;[object Object]&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.concat([])        <span class="regexp">//</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.concat(null)      <span class="regexp">//</span> <span class="string">&quot;null&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span>.concat(<span class="number">4</span>, <span class="number">5</span>)      <span class="regexp">//</span> <span class="string">&quot;45&quot;</span></span><br></pre></td></tr></table></figure><h4 id="15-String-fromCharCode"><a href="#15-String-fromCharCode" class="headerlink" title="15. String.fromCharCode()"></a>15. String.fromCharCode()</h4><p><code>String.fromCharCode()</code>方法返回由指定的UTF-16代码单元序列创建的字符串。</p><p><strong>返回值：</strong> 一个长度为N的字符串，由N个指定的UTF-16代码单元组成。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(<span class="number">189</span>, <span class="number">43</span>, <span class="number">190</span>, <span class="number">61</span>)  <span class="comment">// &quot;½+¾=&quot;</span></span><br></pre></td></tr></table></figure><h4 id="16-String-fromCodePoint"><a href="#16-String-fromCodePoint" class="headerlink" title="16. String.fromCodePoint()"></a>16. String.fromCodePoint()</h4><p><code>String.fromCodePoint()</code>静态方法返回使用指定的代码点序列创建的字符串。</p><p><strong>返回值：</strong> 使用指定的Unicode 编码位置创建的字符串。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(<span class="number">189</span>, <span class="number">43</span>, <span class="number">190</span>, <span class="number">61</span>)  <span class="comment">// &quot;½+¾=&quot;</span></span><br></pre></td></tr></table></figure><h4 id="17-codePointAt"><a href="#17-codePointAt" class="headerlink" title="17. codePointAt()"></a>17. codePointAt()</h4><p><code>codePointAt()</code>方法返回一个Unicode编码点值的非负整数。</p><p><strong>返回值：</strong> 在字符串中的给定索引的编码单元体现的数字，如果在索引处没有找到该元素则返回<code>undefined</code>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.codePointAt(<span class="number">3</span>)  <span class="comment">// 110</span></span><br></pre></td></tr></table></figure><h4 id="18-endsWith"><a href="#18-endsWith" class="headerlink" title="18. endsWith()"></a>18. endsWith()</h4><p><code>endsWith()</code>方法用来判断当前字符串是否是以另外一个给定的子字符串结尾的，根据结果返回true或false。</p><p><strong>参数：</strong></p><ul><li>第一个参数：当前字符串</li><li>第二个参数：字符串的长度，默认是当前字符串的长度</li></ul><p><strong>返回值：</strong> true或false</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.endsWith(<span class="string">&#x27;ly&#x27;</span>)  <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure><h4 id="19-localeCompare"><a href="#19-localeCompare" class="headerlink" title="19. localeCompare()"></a>19. localeCompare()</h4><p><code>localeCompare()</code>方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后与给定字符串相同。</p><p><strong>返回值：</strong> 如果引用字符存在于比较字符之前为<code>负数</code>；如果引用字符存在于比较字符之后则为<code>正数</code>；相等的时候返回0。</p><h4 id="20-match"><a href="#20-match" class="headerlink" title="20. match()"></a>20. match()</h4><p><code>match()</code>方法检索返回一个字符串匹配的正则表达式的结果。</p><p><strong>参数：</strong> 一个正则表达式对象，如果传入一个非正则表达式对象，则会隐式地使用<code>new RegExp(obj)</code>将其转换成一个<code>RegExp</code>；如果没有给出任何参数直接使用match()方法，则会得到一个包含空字符串的Array: [“”]。</p><p><strong>返回值：</strong> </p><ul><li>如果使用g标识，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</li><li>如果未使用g标志，则返回第一个完整匹配及其相关的捕获组（Array）。</li></ul><h4 id="21-matchAll"><a href="#21-matchAll" class="headerlink" title="21. matchAll()"></a>21. matchAll()</h4><p><code> matchAll()</code>方法返回一个包含所有匹配正则表达式的结果及分组捕获数组的迭代器。</p><p><strong>参数：</strong> 正则表达式对象，注意：正则表达式必须是设置了全局模式的g的形式，否则会抛出异常。</p><p><strong>返回值：</strong> 一个迭代器。</p><h4 id="22-normalize"><a href="#22-normalize" class="headerlink" title="22. normalize()"></a>22. normalize()</h4><p><code>normalize()</code>会按照指定的一种Unicode正规形式将当前字符串正规化。（如果该值不是字符串，则首先将其转换为一个字符串）</p><h4 id="23-length"><a href="#23-length" class="headerlink" title="23. length"></a>23. length</h4><p><code>length</code>属性返回字符串的长度</p><h4 id="24-trim"><a href="#24-trim" class="headerlink" title="24. trim"></a>24. trim</h4><p><code>trim()</code>删除字符串两端的空白符</p><h4 id="25-属性访问"><a href="#25-属性访问" class="headerlink" title="25. 属性访问"></a>25. 属性访问</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">str</span> = <span class="symbol">&#x27;school</span>&#x27;;</span><br><span class="line"><span class="built_in">str</span>[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight ebnf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;let str&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;#x27;My name is Lily&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一、提取字符串方法&quot;&gt;&lt;a href=&quot;#一、提取字符串方法&quot; class=&quot;headerlink&quot; title=&quot;一、提取字符串方法&quot;&gt;&lt;/a&gt;一、提取字符串方法&lt;/h3&gt;&lt;h4 id=&quot;1-charAt&quot;&gt;&lt;a href=&quot;#1-charAt&quot; class=&quot;headerlink&quot; title=&quot;1. charAt()&quot;&gt;&lt;/a&gt;1. charAt()&lt;/h4&gt;&lt;p&gt;&lt;code&gt;charAt&lt;/code&gt; 获取字符串的某个字符。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="javascript" scheme="https://chajianyuan.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS：scrollWidth、offsetWidth、clientWidth</title>
    <link href="https://chajianyuan.github.io/2020/11/03/JS%EF%BC%9AscrollWidth%E3%80%81offsetWidth%E3%80%81clientWidth/"/>
    <id>https://chajianyuan.github.io/2020/11/03/JS%EF%BC%9AscrollWidth%E3%80%81offsetWidth%E3%80%81clientWidth/</id>
    <published>2020-11-03T14:01:56.000Z</published>
    <updated>2021-02-10T10:51:01.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Element-clientWidth"><a href="#Element-clientWidth" class="headerlink" title="Element.clientWidth"></a>Element.clientWidth</h3><p>内联元素以及没有css样式的元素的<code>clientWidth</code>值为0。 <code>Element.clientWidth</code>属性表示元素的内部宽度。</p><a id="more"></a><p>该属性包括内边距padding，但不包括边框border、外边距margin和垂直滚动条（如果有的话）。</p><p>⚠️ 当在根元素（&lt; html &gt;元素）上使用<code>clientWidth</code>(或者在&lt; body &gt;上，如果文档是在怪异模式下)，将返回viewport的宽度（不包含任何滚动条）。</p><blockquote><p>这个属性会进行四舍五入并返回整数，如果需要小数形式的值，则使用<code>element.getBoundingClientRect()</code>。</p></blockquote><h3 id="Element-scrollWidth"><a href="#Element-scrollWidth" class="headerlink" title="Element.scrollWidth"></a>Element.scrollWidth</h3><p><code>Element.scrollWidth</code>这个只读属性是元素内容宽度的一种度量，包括由于overflow溢出而在屏幕上不可见的内容。</p><p>scrollWidth值等于元素在不使用水平滚动条的情况下适合视口中的所有内容所需的最小宽度。</p><p>宽度的测量与<code>clientWidth</code>相同：它包括元素的内边距，但是不包括边框、外边距或垂直滚动条（如果存在）。它还可以包括伪元素的宽度，例如<code>::before</code>或<code>::after</code>。如果元素的内容可以适合而不需要水平滚动条，则其<code>scrollWidth</code>等于<code>clientWidth</code>。</p><blockquote><ol><li>这个属性会进行四舍五入并返回整数，如果需要小数形式的值，则使用<code>element.getBoundingClientRect()</code>。</li><li>谷歌获取的<code>Element.scrollWidth</code>和IE、火狐下获取的<code>Element.scrollWidth</code>并不相同。</li></ol></blockquote><h3 id="Element-offsetWidth"><a href="#Element-offsetWidth" class="headerlink" title="Element.offsetWidth"></a>Element.offsetWidth</h3><p><code>Element.offsetWidth</code>是一个只读属性，返回一个元素的布局宽度。</p><p><code>Element.offsetWidth</code>是测量包含元素的边框（border）、水平线上的内边距（padding）、垂直方向上的滚动条、以及css设置的的宽度（width）值。</p><p>⚠️ 各浏览器的offsetWidth可能有所不同。</p><blockquote><p>这个属性会进行四舍五入并返回整数，如果需要小数形式的值，则使用<code>element.getBoundingClientRect()</code>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Element-clientWidth&quot;&gt;&lt;a href=&quot;#Element-clientWidth&quot; class=&quot;headerlink&quot; title=&quot;Element.clientWidth&quot;&gt;&lt;/a&gt;Element.clientWidth&lt;/h3&gt;&lt;p&gt;内联元素以及没有css样式的元素的&lt;code&gt;clientWidth&lt;/code&gt;值为0。 &lt;code&gt;Element.clientWidth&lt;/code&gt;属性表示元素的内部宽度。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="javascript" scheme="https://chajianyuan.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>性能优化：防抖和节流</title>
    <link href="https://chajianyuan.github.io/2020/11/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>https://chajianyuan.github.io/2020/11/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2020-11-01T12:27:58.000Z</published>
    <updated>2021-02-10T10:47:50.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h4><p><strong>原理</strong></p><p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p><a id="more"></a><p><strong>适用场景</strong></p><ol><li>按钮提交场景：防止多次提交按钮，只执行最后提交的一次</li><li>服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写简化版实现</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h4><p><strong>原理</strong></p><p>规定在一个单位时间内只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。防抖是延迟执行，节流是间隔执行，函数节流即每隔一段时间就执行一次。</p><p><strong>适用场景</strong></p><ol><li>拖拽场景：规定时间内只执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器resize</li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写简化版实现</span></span><br><span class="line"><span class="comment">// 1. 定时器实现</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 时间戳实现</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">            preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">            fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;防抖函数&quot;&gt;&lt;a href=&quot;#防抖函数&quot; class=&quot;headerlink&quot; title=&quot;防抖函数&quot;&gt;&lt;/a&gt;防抖函数&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="性能优化" scheme="https://chajianyuan.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>算法：求根到叶子节点数字之和</title>
    <link href="https://chajianyuan.github.io/2020/10/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>https://chajianyuan.github.io/2020/10/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2020-10-29T07:46:05.000Z</published>
    <updated>2021-02-10T10:46:29.763Z</updated>
    
    <content type="html"><![CDATA[<p>💪 打卡算法第四天</p><p>📖 题目来自力扣129题</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><a id="more"></a><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">输出: <span class="number">25</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">2</span> 代表数字 <span class="number">12.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">1</span>-&gt;<span class="number">3</span> 代表数字 <span class="number">13.</span></span><br><span class="line">因此，数字总和 = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25.</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">0</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">5</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">1026</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40.</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026.</span></span><br></pre></td></tr></table></figure><h4 id="🤔-题解"><a href="#🤔-题解" class="headerlink" title="🤔 题解"></a>🤔 题解</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree <span class="type">node</span>.</span><br><span class="line"> * <span class="keyword">function</span> TreeNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.left = this.right = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;TreeNode&#125;<span class="built_in"> root</span></span><br><span class="line"> * @<span class="keyword">return</span> <span class="built_in">&#123;number</span>&#125;</span><br><span class="line"> */</span><br><span class="line">var sumNumbers = <span class="keyword">function</span><span class="built_in">(root</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs<span class="built_in">(root</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const dfs = <span class="built_in">(root</span>, preSum) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">!root</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    const<span class="built_in"> sum</span> = preSum * <span class="number">10</span> +<span class="built_in"> root</span>.val;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">!root</span>.left &amp;&amp; <span class="built_in">!root</span>.right) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> sum</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs<span class="built_in">(root</span>.left,<span class="built_in"> sum</span>) + dfs<span class="built_in">(root</span>.right,<span class="built_in"> sum</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;💪 打卡算法第四天&lt;/p&gt;
&lt;p&gt;📖 题目来自力扣129题&lt;/p&gt;
&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;/p&gt;
&lt;p&gt;例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://chajianyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://chajianyuan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>css: css新特性</title>
    <link href="https://chajianyuan.github.io/2020/10/28/css%EF%BC%9Acss%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://chajianyuan.github.io/2020/10/28/css%EF%BC%9Acss%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-10-28T08:39:01.000Z</published>
    <updated>2021-02-10T10:49:23.603Z</updated>
    
    <content type="html"><![CDATA[<p>🔗 <a href="https://mp.weixin.qq.com/s/HbfThzav79GFS-sMirAINA">2020年你不应该错过的CSS新特性</a></p><h3 id="🍀-Web动效"><a href="#🍀-Web动效" class="headerlink" title="🍀 Web动效"></a>🍀 Web动效</h3><h5 id="🍃-动态模糊"><a href="#🍃-动态模糊" class="headerlink" title="🍃 动态模糊"></a>🍃 动态模糊</h5><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;🔗 &lt;a href=&quot;https://mp.weixin.qq.com/s/HbfThzav79GFS-sMirAINA&quot;&gt;2020年你不应该错过的CSS新特性&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;🍀-Web动效&quot;&gt;&lt;a href=&quot;#🍀-Web动效&quot; class=&quot;headerlink&quot; title=&quot;🍀 Web动效&quot;&gt;&lt;/a&gt;🍀 Web动效&lt;/h3&gt;&lt;h5 id=&quot;🍃-动态模糊&quot;&gt;&lt;a href=&quot;#🍃-动态模糊&quot; class=&quot;headerlink&quot; title=&quot;🍃 动态模糊&quot;&gt;&lt;/a&gt;🍃 动态模糊&lt;/h5&gt;</summary>
    
    
    
    
    <category term="css" scheme="https://chajianyuan.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>react: useEffect</title>
    <link href="https://chajianyuan.github.io/2020/10/27/react%EF%BC%9AuseEffect/"/>
    <id>https://chajianyuan.github.io/2020/10/27/react%EF%BC%9AuseEffect/</id>
    <published>2020-10-27T11:46:05.000Z</published>
    <updated>2021-02-10T10:51:22.714Z</updated>
    
    <content type="html"><![CDATA[<p>本文是在学习<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">useEffect完整指南</a>中做的笔记，记录自己不理解的地方以及学到的知识。</p><h3 id="🍀-每一次渲染都有它自己的Props和State"><a href="#🍀-每一次渲染都有它自己的Props和State" class="headerlink" title="🍀 每一次渲染都有它自己的Props和State"></a>🍀 每一次渲染都有它自己的Props和State</h3><h3 id="🍀-每一次渲染都有它自己的事件处理函数"><a href="#🍀-每一次渲染都有它自己的事件处理函数" class="headerlink" title="🍀 每一次渲染都有它自己的事件处理函数"></a>🍀 每一次渲染都有它自己的事件处理函数</h3><a id="more"></a><h3 id="🍀-每一次渲染都有它自己的Effects"><a href="#🍀-每一次渲染都有它自己的Effects" class="headerlink" title="🍀 每一次渲染都有它自己的Effects"></a>🍀 每一次渲染都有它自己的Effects</h3><p>每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）都会捕捉某次渲染中定义的props和state。</p><p>React会根据我们当前的props和state同步到DOM。</p><p>useEffect使你能够根据props和state同步React tree之外的东西。</p><p>useEffect中的依赖项用来告诉React去对比你的Effects。</p><h3 id="🍀-关于依赖项不要对React撒谎"><a href="#🍀-关于依赖项不要对React撒谎" class="headerlink" title="🍀 关于依赖项不要对React撒谎"></a>🍀 关于依赖项不要对React撒谎</h3><ul><li><p>诚实告知依赖</p><ul><li><p>在依赖中包含所有effect中用到的组件内的值。</p></li><li><p>修改effect内部的代码，以确保它包含的值只会在需要的时候发生变更。</p></li></ul></li></ul><h3 id="🍀-函数式更新"><a href="#🍀-函数式更新" class="headerlink" title="🍀 函数式更新"></a>🍀 函数式更新</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    const id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(id);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure><p>例如用<code>setCount(c =&gt; c + 1)</code> 代替  <code>setCount(count+1)</code>, 在effect中传递最小的信息</p><h3 id="🍀-解耦来自Actions的更新"><a href="#🍀-解耦来自Actions的更新" class="headerlink" title="🍀 解耦来自Actions的更新"></a>🍀 解耦来自Actions的更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = useState(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + step);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;input value=&#123;step&#125; onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> setStep(<span class="built_in">Number</span>(e.target.value))&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要使用<code>useReducer</code>去替换它们。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [<span class="keyword">state</span>, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"><span class="keyword">const</span> &#123; count, step &#125; = <span class="keyword">state</span>;</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">set</span>Interval(() =&gt; &#123;</span><br><span class="line">    dispatch(&#123; type: &#x27;tick&#x27; &#125;); // Instead of <span class="built_in">set</span>Count(c =&gt; c + step);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  return () =&gt; clearInterval(id);</span><br><span class="line">&#125;, [dispatch]);</span><br></pre></td></tr></table></figure><p>React会保证<code>dispatch</code>在组件的生命周期内保持不变。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是在学习&lt;a href=&quot;https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/&quot;&gt;useEffect完整指南&lt;/a&gt;中做的笔记，记录自己不理解的地方以及学到的知识。&lt;/p&gt;
&lt;h3 id=&quot;🍀-每一次渲染都有它自己的Props和State&quot;&gt;&lt;a href=&quot;#🍀-每一次渲染都有它自己的Props和State&quot; class=&quot;headerlink&quot; title=&quot;🍀 每一次渲染都有它自己的Props和State&quot;&gt;&lt;/a&gt;🍀 每一次渲染都有它自己的Props和State&lt;/h3&gt;&lt;h3 id=&quot;🍀-每一次渲染都有它自己的事件处理函数&quot;&gt;&lt;a href=&quot;#🍀-每一次渲染都有它自己的事件处理函数&quot; class=&quot;headerlink&quot; title=&quot;🍀 每一次渲染都有它自己的事件处理函数&quot;&gt;&lt;/a&gt;🍀 每一次渲染都有它自己的事件处理函数&lt;/h3&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://chajianyuan.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="https://chajianyuan.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>vue：vue版本之间的区别</title>
    <link href="https://chajianyuan.github.io/2020/03/27/vue%EF%BC%9Avue%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://chajianyuan.github.io/2020/03/27/vue%EF%BC%9Avue%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-27T00:51:17.000Z</published>
    <updated>2020-03-27T00:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/80/v2-120c6f2e62e740210a77ab3c87d65c0e_1440w.jpg"></p><a id="more"></a><ul><li><p>运行时版本 vue.runtime.js</p><ul><li><p>不支持从 html 获取视图；</p></li><li><p>不支持 template，需要通过 webpack 的工具 vue-loader 将组件，预编译 template 模板为 render 函数；</p></li><li><p>没有 complier 编译器，因此代码体积会比完整版小 40%，html 转化成节点。</p><p><code>&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.9/vue.runtime.min.js&quot;&gt;&lt;/script&gt;</code></p></li></ul></li><li><p>完整版 vue.js</p><ul><li>支持从 html 获取视图；</li><li>支持 template；</li><li>有 complier 编译器，而 complier 可以将字符串<br><code>&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-120c6f2e62e740210a77ab3c87d65c0e_1440w.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="vue" scheme="https://chajianyuan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Node：学习koa.js</title>
    <link href="https://chajianyuan.github.io/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0koa.js/"/>
    <id>https://chajianyuan.github.io/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0koa.js/</id>
    <published>2020-03-26T01:01:10.000Z</published>
    <updated>2020-03-26T01:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、优缺点"><a href="#一、优缺点" class="headerlink" title="一、优缺点"></a>一、优缺点</h2><ul><li><strong>优点：</strong>no callback</li><li><strong>缺点：</strong>content/express 的中间件基本不能重用，基本要重写；依然需要更多人的支持和学习。</li></ul><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、优缺点&quot;&gt;&lt;a href=&quot;#一、优缺点&quot; class=&quot;headerlink&quot; title=&quot;一、优缺点&quot;&gt;&lt;/a&gt;一、优缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;no callback&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;content/express 的中间件基本不能重用，基本要重写；依然需要更多人的支持和学习。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="koa" scheme="https://chajianyuan.github.io/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>Node：学习Express.js</title>
    <link href="https://chajianyuan.github.io/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0Express.js/"/>
    <id>https://chajianyuan.github.io/2020/03/26/Node%EF%BC%9A%E5%AD%A6%E4%B9%A0Express.js/</id>
    <published>2020-03-26T00:50:44.000Z</published>
    <updated>2020-03-26T00:50:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、优缺点"><a href="#一、优缺点" class="headerlink" title="一、优缺点"></a>一、优缺点</h2><ul><li><strong>优点：</strong>历史悠久，文档更完整，资料更多，深入人心；</li><li><strong>缺点：</strong>不能忍的 callback</li></ul><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、优缺点&quot;&gt;&lt;a href=&quot;#一、优缺点&quot; class=&quot;headerlink&quot; title=&quot;一、优缺点&quot;&gt;&lt;/a&gt;一、优缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;历史悠久，文档更完整，资料更多，深入人心；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;不能忍的 callback&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="node" scheme="https://chajianyuan.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>总结：Node.js</title>
    <link href="https://chajianyuan.github.io/2020/03/26/%E6%80%BB%E7%BB%93%EF%BC%9ANode.js/"/>
    <id>https://chajianyuan.github.io/2020/03/26/%E6%80%BB%E7%BB%93%EF%BC%9ANode.js/</id>
    <published>2020-03-26T00:45:13.000Z</published>
    <updated>2020-03-26T00:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Express-js"><a href="#1、Express-js" class="headerlink" title="1、Express.js"></a>1、Express.js</h2><p><a href="">参见总结：Node：学习 Express.js</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、Express-js&quot;&gt;&lt;a href=&quot;#1、Express-js&quot; class=&quot;headerlink&quot; title=&quot;1、Express.js&quot;&gt;&lt;/a&gt;1、Express.js&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;参见总结：Node：学习 Express.js&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="https://chajianyuan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>网络协议：http和https</title>
    <link href="https://chajianyuan.github.io/2020/03/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Ahttp%E5%92%8Chttps/"/>
    <id>https://chajianyuan.github.io/2020/03/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%9Ahttp%E5%92%8Chttps/</id>
    <published>2020-03-25T00:39:45.000Z</published>
    <updated>2020-03-25T01:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、http"><a href="#一、http" class="headerlink" title="一、http"></a>一、http</h2><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ef70cbdc63e95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>HTTP 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，适用于从万维网服务器传输文本到本地浏览器的传送协议。</p><a id="more"></a><h3 id="1、http-1-1-的缺陷"><a href="#1、http-1-1-的缺陷" class="headerlink" title="1、http/1.1 的缺陷"></a>1、http/1.1 的缺陷</h3><ul><li>高延迟–带来页面加载速度的降低；</li><li>无状态特性–带来的巨大 HTTP 头部；</li><li>明文传输–带来的不安全性；</li><li>不支持服务器推送消息。</li></ul><h3 id="2、http-2"><a href="#2、http-2" class="headerlink" title="2、http/2"></a>2、http/2</h3><p><strong>新特性：</strong></p><ul><li>二进制传输；</li><li>Header 压缩；</li><li>多路复用；</li><li>Server Push；</li><li>提高安全性</li></ul><p><strong>缺陷：</strong></p><ul><li>TCP 以及 TCP+TLS 建立连接的延时；</li><li>TCP 的队头阻塞并没有彻底解决。</li></ul><h3 id="3、HTTP-3"><a href="#3、HTTP-3" class="headerlink" title="3、HTTP/3"></a>3、HTTP/3</h3><p><strong>QUIC</strong>是基于 UDP 的一个协议，让 http 跑在 QUIC 上而不是 TCP 上。而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本–HTTP/3。</p><h4 id="QUIC-新功能"><a href="#QUIC-新功能" class="headerlink" title="QUIC 新功能"></a>QUIC 新功能</h4><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能；</li><li>实现了快速握手功；</li><li>集成了 TLS 加密功能；</li><li>多路复用，彻底解决 TCP 中队头阻塞的问题。</li></ul><h2 id="二、HTTPS"><a href="#二、HTTPS" class="headerlink" title="二、HTTPS"></a>二、HTTPS</h2><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。</p><p><strong>HTTP 和 HTTPS 的区别：</strong></p><ul><li>HTTP 是明文传输，HTTPS 通过 SSL/TLS 进行了加密；</li><li>HTTP 的端口号是 80，HTTPS 的是 443；</li><li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费；</li><li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><p><a href="https://juejin.im/post/5b1e93aa5188257d3914280e">掘金：关于 http 协议，你必须要知道的</a></p><p><a href="https://juejin.im/post/5d9abde7e51d4578110dc77f">掘金：解密 http/2 与 http/3 的新特性</a></p><p><a href="https://juejin.im/post/59e4c02151882578d02f4aca">掘金：谈谈 HTTPS</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、http&quot;&gt;&lt;a href=&quot;#一、http&quot; class=&quot;headerlink&quot; title=&quot;一、http&quot;&gt;&lt;/a&gt;一、http&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/11/163ef70cbdc63e95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，适用于从万维网服务器传输文本到本地浏览器的传送协议。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="网络协议" scheme="https://chajianyuan.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>浏览器：一个URL从输入到显示的过程</title>
    <link href="https://chajianyuan.github.io/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://chajianyuan.github.io/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2020-03-24T12:29:48.000Z</published>
    <updated>2020-03-24T12:29:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、查找浏览器缓存，如果没有则进行-DNS-解析"><a href="#1、查找浏览器缓存，如果没有则进行-DNS-解析" class="headerlink" title="1、查找浏览器缓存，如果没有则进行 DNS 解析"></a>1、查找浏览器缓存，如果没有则进行 DNS 解析</h3><p>当在浏览器中输入一个 URL 时，最开始要去浏览器缓存中查找，浏览器缓存分为强缓存和协商缓存，强缓存指不需要向服务器发送请求，直接从缓存中读取资源，状态码为 200，协商缓存是指当强缓存失效后，浏览器携带缓存标识向服务器发送请求，如果资源没有改变就返回 304，更新缓存，如果资源改变就返回 200 和新的资源，如果浏览器中不存在缓存，就通过 DNS 服务器启动一个 DNS 查询，获得 URL 对应的 IP 地址</p><a id="more"></a><h3 id="2、TCP-连接：TCP-三次握手"><a href="#2、TCP-连接：TCP-三次握手" class="headerlink" title="2、TCP 连接：TCP 三次握手"></a>2、TCP 连接：TCP 三次握手</h3><ul><li>第一次握手，由浏览器发起，告诉服务器我要发起请求了</li><li>第二次握手，由服务器发起，告诉浏览器，我已经准备接收了，你可以发送请求了</li><li>第三次握手，由浏览器发起，告诉服务器，我马上发送了，准备接收吧</li></ul><p><strong>三次握手的目的</strong>：防止已失效的连接请求报文段突然又传送到了服务器端，因而产生错误</p><h3 id="3、发送-HTTP-请求"><a href="#3、发送-HTTP-请求" class="headerlink" title="3、发送 HTTP 请求"></a>3、发送 HTTP 请求</h3><h3 id="4、服务器处理请求并返回-HTTP-报文"><a href="#4、服务器处理请求并返回-HTTP-报文" class="headerlink" title="4、服务器处理请求并返回 HTTP 报文"></a>4、服务器处理请求并返回 HTTP 报文</h3><h3 id="5、浏览器解析渲染页面"><a href="#5、浏览器解析渲染页面" class="headerlink" title="5、浏览器解析渲染页面"></a>5、浏览器解析渲染页面</h3><ol><li>根据 HTML 解析 DOM 树</li><li>根据 CSS 解析生成 CSS 规则树</li><li>结合 DOM 树和 CSS 规则树，生成渲染树</li><li>根据渲染树计算每一个节点的信息</li><li>根据计算好的信息绘制页面</li></ol><h3 id="6、断开连接：TCP-四次挥手"><a href="#6、断开连接：TCP-四次挥手" class="headerlink" title="6、断开连接：TCP 四次挥手"></a>6、断开连接：TCP 四次挥手</h3><p><a href="https://juejin.im/post/5bf3ad55f265da61682afc9b">掘金：从 URL 输入到页面展现到底发生什么？</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、查找浏览器缓存，如果没有则进行-DNS-解析&quot;&gt;&lt;a href=&quot;#1、查找浏览器缓存，如果没有则进行-DNS-解析&quot; class=&quot;headerlink&quot; title=&quot;1、查找浏览器缓存，如果没有则进行 DNS 解析&quot;&gt;&lt;/a&gt;1、查找浏览器缓存，如果没有则进行 DNS 解析&lt;/h3&gt;&lt;p&gt;当在浏览器中输入一个 URL 时，最开始要去浏览器缓存中查找，浏览器缓存分为强缓存和协商缓存，强缓存指不需要向服务器发送请求，直接从缓存中读取资源，状态码为 200，协商缓存是指当强缓存失效后，浏览器携带缓存标识向服务器发送请求，如果资源没有改变就返回 304，更新缓存，如果资源改变就返回 200 和新的资源，如果浏览器中不存在缓存，就通过 DNS 服务器启动一个 DNS 查询，获得 URL 对应的 IP 地址&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="浏览器" scheme="https://chajianyuan.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>css：css的引入方式</title>
    <link href="https://chajianyuan.github.io/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>https://chajianyuan.github.io/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2020-03-22T01:48:54.000Z</published>
    <updated>2020-03-22T01:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、css-的引入方式有三种"><a href="#1、css-的引入方式有三种" class="headerlink" title="1、css 的引入方式有三种"></a>1、css 的引入方式有三种</h3><p>（1）行内式将样式写在元素的 style 属性里面</p><p>（2）内嵌式将样式写在&lt; style &gt;元素里面</p><p>（3）外链式指通过 link 标签引入 css 文件</p><a id="more"></a><h3 id="2、link-和-import-引入样式文件的区别"><a href="#2、link-和-import-引入样式文件的区别" class="headerlink" title="2、link 和@import 引入样式文件的区别"></a>2、link 和@import 引入样式文件的区别</h3><p>（1）加载资源的限制</p><p>link 是 XHTML 的标签，除了加载 css 文件之外，还能加载 RSS 等其他事务，如加载模板等；</p><p>@import 只能加载 css 文件</p><p>（2）加载方式</p><p>用 link 引用 css，在页面载入时同时加载，即同步加载；</p><p>用@import 引用 css，则需要等到网页完全载入后，再加载 css 文件，即异步加载</p><p>（3）兼容性</p><p>link 是 XHTML 标签，没有兼容问题</p><p>@import 是在 css2.1 中提出的，不支持低版本的浏览器</p><p>（4）改变样式</p><p>link 的标签是 DOM 元素，支持使用 JavaScript 控制 DOM 和修改样式</p><p>@import 是一种方法，不支持控制 DOM 和修改元素</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、css-的引入方式有三种&quot;&gt;&lt;a href=&quot;#1、css-的引入方式有三种&quot; class=&quot;headerlink&quot; title=&quot;1、css 的引入方式有三种&quot;&gt;&lt;/a&gt;1、css 的引入方式有三种&lt;/h3&gt;&lt;p&gt;（1）行内式将样式写在元素的 style 属性里面&lt;/p&gt;
&lt;p&gt;（2）内嵌式将样式写在&amp;lt; style &amp;gt;元素里面&lt;/p&gt;
&lt;p&gt;（3）外链式指通过 link 标签引入 css 文件&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="css" scheme="https://chajianyuan.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JS：map、filter、reduce</title>
    <link href="https://chajianyuan.github.io/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/"/>
    <id>https://chajianyuan.github.io/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/</id>
    <published>2020-03-22T01:28:46.000Z</published>
    <updated>2020-03-22T01:28:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、map"><a href="#1、map" class="headerlink" title="1、map"></a>1、map</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((item, index, <span class="built_in">array</span>)=&gt; item = item+<span class="number">1</span>)  =&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>map</code>的回调函数可接受三个参数，遍历原数组，对每个元素进行操作，返回一个新数组。</p><h3 id="2、filter"><a href="#2、filter" class="headerlink" title="2、filter"></a>2、filter</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((item, index, <span class="built_in">array</span>)=&gt; item != <span class="number">2</span>)  =&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><code>filter</code> 的回调函数也可以接受三个参数，在遍历原数组事，将返回值为 true 的元素放在新数组中，返回新数组。</p><h3 id="3、reduce"><a href="#3、reduce" class="headerlink" title="3、reduce"></a>3、reduce</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((acc, current) =&gt; acc+ current, <span class="number">0</span>)  =&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>reduce</code>接收两个参数，分别是回调函数和初始值。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1、map&quot;&gt;&lt;a href=&quot;#1、map&quot; class=&quot;headerlink&quot; title=&quot;1、map&quot;&gt;&lt;/a&gt;1、map&lt;/h3&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr.map((item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;)=&amp;gt; item = item+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)  =&amp;gt; [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="javascript" scheme="https://chajianyuan.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>总结：React</title>
    <link href="https://chajianyuan.github.io/2020/03/09/%E6%80%BB%E7%BB%93%EF%BC%9AReact/"/>
    <id>https://chajianyuan.github.io/2020/03/09/%E6%80%BB%E7%BB%93%EF%BC%9AReact/</id>
    <published>2020-03-09T02:52:51.000Z</published>
    <updated>2021-02-10T10:48:27.488Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、当调用-setState-的时候-发生了什么？"><a href="#一、当调用-setState-的时候-发生了什么？" class="headerlink" title="一、当调用 setState 的时候,发生了什么？"></a>一、当调用 setState 的时候,发生了什么？</h2><p>当调用 setState 时，React 做的第一件事就是将传递给 setState 的对象合并到组件的当前状态，这将启动一个称为和解的过程，和解的最终目标是，根据这个新的状态以最有效的方式更新 DOM。为此，React 将构建一个新的 React 虚拟 DOM 树（可以将其视为页面 DOM 元素的对象表示方式）。</p><a id="more"></a><p>一旦有了这个 DOM 树，为了弄清 DOM 是如何响应新的状态而改变的，React 会将这个新树与上一个虚拟 DOM 树比较。</p><p>这样做，React 会知道发生的确切变化，并且通过了解发生的变化后，在绝对必要的情况下进行更新 DOM，即可将因操作 DOM 而占用的空间最小化。</p><h2 id="二、在-React-中元素（element）和组件（component）有什么区别？"><a href="#二、在-React-中元素（element）和组件（component）有什么区别？" class="headerlink" title="二、在 React 中元素（element）和组件（component）有什么区别？"></a>二、在 React 中元素（element）和组件（component）有什么区别？</h2><p>简单的说，在 React 中元素（虚拟 DOM）描述了你在屏幕上看到的 DOM 元素。换个说法就是，在 React 中元素是页面中 DOM 元素的对象表示方式，在 React 中组件是一个函数或一个类，它可以接受输入并返回一个元素。</p><blockquote><p>提醒：工作中，为了提高开发效率，通常使用 JSX 语法表示 React 元素（虚拟 DOM）。在编译的时候，把它转化成一个 React.creatElement 调用方法。</p></blockquote><h2 id="三、什么时候使用类组件（Class-Component）？什么时候使用功能组件（Functional-Component）？"><a href="#三、什么时候使用类组件（Class-Component）？什么时候使用功能组件（Functional-Component）？" class="headerlink" title="三、什么时候使用类组件（Class Component）？什么时候使用功能组件（Functional Component）？"></a>三、什么时候使用类组件（Class Component）？什么时候使用功能组件（Functional Component）？</h2><p>如果使用组件具有状态（state）或生命周期方法，请使用类组件；否则使用功能组件。</p><h2 id="四、什么是-React-的-refs？为什么它们很重要？"><a href="#四、什么是-React-的-refs？为什么它们很重要？" class="headerlink" title="四、什么是 React 的 refs？为什么它们很重要？"></a>四、什么是 React 的 refs？为什么它们很重要？</h2><p>refs 允许你直接访问 DOM 元素或组件实例，为了使用它们，可以向组件添加一个 ref 属性。</p><p>如果该属性的值是一个回调函数，它将接受底层的 DOM 元素或组件的已挂载实例作为其第一个参数。可以在组件中存储它。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  showResult() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.input.value);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">&quot;text&quot;</span> ref=&#123; input =&gt; <span class="keyword">this</span>.input = input&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123; <span class="keyword">this</span>.showResult.bind(<span class="keyword">this</span>) &#125;&gt; 展示结果 &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该属性值是一个字符串，React 将会在组件实例化对象的 refs 属性中，存储一个同名属性，该属性是对这个 DOM 元素的引用，可以通过原生的 DOM API 操作它。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  showResult() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.refs.username.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">&quot;text&quot;</span> ref=<span class="string">&quot;username&quot;</span> /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.showResult.bind(<span class="keyword">this</span>)&#125;&gt;展示结果&lt;/button&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、React-中的-key-是什么？为什么它们很重要？"><a href="#五、React-中的-key-是什么？为什么它们很重要？" class="headerlink" title="五、React 中的 key 是什么？为什么它们很重要？"></a>五、React 中的 key 是什么？为什么它们很重要？</h2><p>key 可以帮助 React 跟踪循环创建列表中的虚拟 DOM 元素，了解哪些元素已更改、添加或删除。</p><p>每个绑定 key 的虚拟 DOM 元素，在兄弟元素之间都是独一无二的。在 React 的和解过程中，比较新的虚拟 DOM 树与上一个虚拟 DOM 树之间的差异，并映射到页面中。key 使 React 处理列表中虚拟 DOM 时更加高效，因为 React 可以使用虚拟 DOM 上的 key 属性，快速了解元素是新的，还是需要删除的，还是修改过的。如果没有 key，React 就不知道列表中虚拟 DOM 元素与页面中的哪个元素相对应，所以在创建列表的时候，不要忽略 key。</p><h2 id="六、如果创建了类似于下面的-Icketang-元素，那么该如何实现-Icketang-类？"><a href="#六、如果创建了类似于下面的-Icketang-元素，那么该如何实现-Icketang-类？" class="headerlink" title="六、如果创建了类似于下面的 Icketang 元素，那么该如何实现 Icketang 类？"></a>六、如果创建了类似于下面的 Icketang 元素，那么该如何实现 Icketang 类？</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="type">Icketang</span> username=<span class="string">&quot;雨夜清荷&quot;</span>&gt;</span><br><span class="line">  &#123;user =&gt; user ? &lt;<span class="type">Info</span> user=&#123;user&#125; /&gt; : &lt;<span class="type">Loading</span> /&gt;&#125;</span><br><span class="line">&lt;/<span class="type">Icketang</span>&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123;<span class="type">Component</span>&#125; from <span class="string">&quot;react&quot;</span>;</span><br><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">Icketang</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请实现代码</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      user: props.user</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// 模拟异步获取数据操作，更新状态</span></span><br><span class="line">    setTimeout(()=&gt; <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      user: &#x27;爱创课堂&#x27;</span><br><span class="line">    &#125;), <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children(<span class="keyword">this</span>.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loading</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;<span class="type">Loading</span>...&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;&#123;<span class="keyword">this</span>.props.user&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、约束性组件（controlled-component）与非约束性组件（uncontrolled-component）有什么区别？"><a href="#七、约束性组件（controlled-component）与非约束性组件（uncontrolled-component）有什么区别？" class="headerlink" title="七、约束性组件（controlled component）与非约束性组件（uncontrolled component）有什么区别？"></a>七、约束性组件（controlled component）与非约束性组件（uncontrolled component）有什么区别？</h2><p>在 React 中，组件负责控制和管理自己的状态。</p><p>如果将 HTML 中的表单元素（input、select、textarea 等）添加到组件中，当用户与表单发生交互时，就设计表单数据存储问题。根据表单数据存储问题。根据表单数据的存储位置，将组件分成约束性组件和非约束性组件。</p><p>约束性组件（controlled component）就是由 React 控制的组件。</p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、当调用-setState-的时候-发生了什么？&quot;&gt;&lt;a href=&quot;#一、当调用-setState-的时候-发生了什么？&quot; class=&quot;headerlink&quot; title=&quot;一、当调用 setState 的时候,发生了什么？&quot;&gt;&lt;/a&gt;一、当调用 setState 的时候,发生了什么？&lt;/h2&gt;&lt;p&gt;当调用 setState 时，React 做的第一件事就是将传递给 setState 的对象合并到组件的当前状态，这将启动一个称为和解的过程，和解的最终目标是，根据这个新的状态以最有效的方式更新 DOM。为此，React 将构建一个新的 React 虚拟 DOM 树（可以将其视为页面 DOM 元素的对象表示方式）。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="https://chajianyuan.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JS：赋值、深拷贝和浅拷贝</title>
    <link href="https://chajianyuan.github.io/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://chajianyuan.github.io/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-02-24T00:46:35.000Z</published>
    <updated>2020-02-24T00:46:38.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、浅拷贝和深拷贝"><a href="#一、浅拷贝和深拷贝" class="headerlink" title="一、浅拷贝和深拷贝"></a>一、浅拷贝和深拷贝</h2><p>浅拷贝和深拷贝只针对 object 和 array 这种引用数据类型。</p><a id="more"></a><p><strong>浅拷贝：</strong> 只复制某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p><p><strong>深拷贝：</strong> 会创造一个一模一样的新对象，新对象和原对象不共享内存，修改新对象不会改到原对象。</p><h2 id="二、赋值和浅拷贝"><a href="#二、赋值和浅拷贝" class="headerlink" title="二、赋值和浅拷贝"></a>二、赋值和浅拷贝</h2><p><strong>赋值：</strong> 当把某个对象赋值给一个新的变量时，赋的是该对象在栈中的地址，而不是堆中的数据。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> a =&#123;</span><br><span class="line">  <span class="built_in">na</span><span class="symbol">me:</span> <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">  scor<span class="symbol">es:</span> [<span class="number">100</span>, <span class="number">99</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">var</span> b = a;</span><br></pre></td></tr></table></figure><p>其实是将对象 a 在栈中的指针 a 赋值给了对象 b,指针 a 和指针 b 指向的是同一个堆中的数据，那么其中一个数据改变时，另外一个也会改变。</p><p><strong>浅拷贝：</strong> 浅拷贝会创建一个新的对象，但它是按位拷贝对象，即如果原对象的属性是基本类型，则拷贝的是基本数据类型的值；如果原对象的属性是引用数据类型，则拷贝的是引用类型的指针。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/23/167da74d45d3103b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="三、浅拷贝的实现方式"><a href="#三、浅拷贝的实现方式" class="headerlink" title="三、浅拷贝的实现方式"></a>三、浅拷贝的实现方式</h2><h3 id="1、Object-assign"><a href="#1、Object-assign" class="headerlink" title="1、Object.assign()"></a>1、Object.assign()</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> obj = &#123;</span><br><span class="line">  <span class="selector-tag">a</span>: &#123;</span><br><span class="line">    <span class="selector-tag">a</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="selector-tag">b</span>: <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> copyObj = Object.assign(&#123;&#125;, obj)</span><br></pre></td></tr></table></figure><h3 id="2、Array-prototype-concat"><a href="#2、Array-prototype-concat" class="headerlink" title="2、Array.prototype.concat()"></a>2、Array.prototype.concat()</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var</span> <span class="string">obj = &#123;</span></span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;zhangsan&#x27;,</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">var</span> <span class="string">copyObj = obj.concat();</span></span><br></pre></td></tr></table></figure><h3 id="3、Array-prototype-slice"><a href="#3、Array-prototype-slice" class="headerlink" title="3、Array.prototype.slice()"></a>3、Array.prototype.slice()</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var</span> <span class="string">obj = &#123;</span></span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;zhangsan&#x27;,</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">var</span> <span class="string">copyObj = obj.slice();</span></span><br></pre></td></tr></table></figure><h2 id="四、深拷贝的实现方式"><a href="#四、深拷贝的实现方式" class="headerlink" title="四、深拷贝的实现方式"></a>四、深拷贝的实现方式</h2><h3 id="1、JSON-parse-JSON-stringify"><a href="#1、JSON-parse-JSON-stringify" class="headerlink" title="1、JSON.parse(JSON.stringify())"></a>1、JSON.parse(JSON.stringify())</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    b: <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> copyObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br></pre></td></tr></table></figure><h3 id="2、手写递归方法"><a href="#2、手写递归方法" class="headerlink" title="2、手写递归方法"></a>2、手写递归方法</h3><p>遍历对象、数组直到里面都是基本数据类型，然后再去复制。</p><h3 id="3、函数库-lodash"><a href="#3、函数库-lodash" class="headerlink" title="3、函数库 lodash"></a>3、函数库 lodash</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    a: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    b: <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> copyObj = _.cloneDeep(obj);</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/5b5dcf8351882519790c9a2e">浅拷贝与深拷贝</a></p>]]></content>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、浅拷贝和深拷贝&quot;&gt;&lt;a href=&quot;#一、浅拷贝和深拷贝&quot; class=&quot;headerlink&quot; title=&quot;一、浅拷贝和深拷贝&quot;&gt;&lt;/a&gt;一、浅拷贝和深拷贝&lt;/h2&gt;&lt;p&gt;浅拷贝和深拷贝只针对 object 和 array 这种引用数据类型。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://chajianyuan.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="javascript" scheme="https://chajianyuan.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
