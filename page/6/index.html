<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chajianyuan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"ZFO5FC3GGP","apiKey":"ebb197ff3f64dd809727fafc95ab1151","indexName":"test_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="查见原的博客">
<meta property="og:url" content="https://chajianyuan.github.io/page/6/index.html">
<meta property="og:site_name" content="查见原的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chajianyuan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chajianyuan.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>查见原的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="查见原的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">查见原的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">越努力，越幸运</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/13/css%EF%BC%9Aflex%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/13/css%EF%BC%9Aflex%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">css：flex布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-13 09:53:53" itemprop="dateCreated datePublished" datetime="2019-10-13T09:53:53+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 15:38:14" itemprop="dateModified" datetime="2020-03-22T15:38:14+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、容器的属性"><a href="#一、容器的属性" class="headerlink" title="一、容器的属性"></a>一、容器的属性</h2><h3 id="1、flex-direction"><a href="#1、flex-direction" class="headerlink" title="1、flex-direction"></a>1、flex-direction</h3><p>定义主轴的方向。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png"></p>
<h3 id="2、flex-wrap"><a href="#2、flex-wrap" class="headerlink" title="2、flex-wrap"></a>2、flex-wrap</h3><p>定义如果一行排不下，如何换行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: npwrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="nowrap"><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="wrap"><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="wrap-reverse"></p>
<h3 id="3、flex-flow"><a href="#3、flex-flow" class="headerlink" title="3、flex-flow"></a>3、flex-flow</h3><p>flex-direction 和 flex-wrap 的简写，默认值为 row nowrap。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">  flex-flow：<span class="params">&lt;flex-direction&gt;</span> || <span class="params">&lt;flex-row&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、justify-content"><a href="#4、justify-content" class="headerlink" title="4、justify-content"></a>4、justify-content</h3><p>定义了项目在主轴上的对齐方式。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">box</span> &#123;</span><br><span class="line">  <span class="built_in">display</span>: flex;</span><br><span class="line">  justify-<span class="built_in">content</span>：flex-start | flex-end | <span class="built_in">center</span> | <span class="built_in">space</span>-between | <span class="built_in">space</span>-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png"></p>
<h3 id="5、align-items"><a href="#5、align-items" class="headerlink" title="5、align-items"></a>5、align-items</h3><p>定义了项目在交叉轴上如何对齐。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items：flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png"></p>
<h3 id="6、align-content"><a href="#6、align-content" class="headerlink" title="6、align-content"></a>6、align-content</h3><p>定义了多个项目在主轴上的对齐方式。如果只有一个项目则该属性不奏效。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-content：flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png"></p>
<h2 id="二、项目的属性"><a href="#二、项目的属性" class="headerlink" title="二、项目的属性"></a>二、项目的属性</h2><h3 id="1、order"><a href="#1、order" class="headerlink" title="1、order"></a>1、order</h3><p>定义项目的排列顺序。数值越小，排列越靠前，默认值为 0。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  order： <span class="params">&lt;integer&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png"></p>
<h3 id="2、flex-grow"><a href="#2、flex-grow" class="headerlink" title="2、flex-grow"></a>2、flex-grow</h3><p>定义项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex-grow：<span class="params">&lt;number&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png"></p>
<h3 id="3、flex-shrink"><a href="#3、flex-shrink" class="headerlink" title="3、flex-shrink"></a>3、flex-shrink</h3><p>定义了项目的缩小比例，默认值为 1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex-shrink：<span class="params">&lt;number&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg"></p>
<h3 id="4、flex-basis"><a href="#4、flex-basis" class="headerlink" title="4、flex-basis"></a>4、flex-basis</h3><p>定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。默认值为 auto，即项目本身的大小。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex-basis：<span class="params">&lt;length&gt;</span> | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、flex"><a href="#5、flex" class="headerlink" title="5、flex"></a>5、flex</h3><p>flex-grow，flex-shrink，flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex：none | <span class="params">&lt;flex-grow&gt;</span> <span class="params">&lt;flex-shrink&gt;</span>? || <span class="params">&lt;flex-basis&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、align-self"><a href="#6、align-self" class="headerlink" title="6、align-self"></a>6、align-self</h3><p>允许单个项目有不同于其他项目在交叉轴上的对齐方式，可以覆盖 align-items。默认为 auto，表示继承父元素的 align-items 属性，如果父元素没有 align-items 属性，则等同于 stretch。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  align-self：<span class="built_in">auto</span> | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png"></p>
<p>参照<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰的 Flex 布局教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">css：css的引入方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-22 09:48:54 / 修改时间：09:48:57" itemprop="dateCreated datePublished" datetime="2020-03-22T09:48:54+08:00">2020-03-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、css-的引入方式有三种"><a href="#1、css-的引入方式有三种" class="headerlink" title="1、css 的引入方式有三种"></a>1、css 的引入方式有三种</h3><p>（1）行内式将样式写在元素的 style 属性里面</p>
<p>（2）内嵌式将样式写在&lt; style &gt;元素里面</p>
<p>（3）外链式指通过 link 标签引入 css 文件</p>
<h3 id="2、link-和-import-引入样式文件的区别"><a href="#2、link-和-import-引入样式文件的区别" class="headerlink" title="2、link 和@import 引入样式文件的区别"></a>2、link 和@import 引入样式文件的区别</h3><p>（1）加载资源的限制</p>
<p>link 是 XHTML 的标签，除了加载 css 文件之外，还能加载 RSS 等其他事务，如加载模板等；</p>
<p>@import 只能加载 css 文件</p>
<p>（2）加载方式</p>
<p>用 link 引用 css，在页面载入时同时加载，即同步加载；</p>
<p>用@import 引用 css，则需要等到网页完全载入后，再加载 css 文件，即异步加载</p>
<p>（3）兼容性</p>
<p>link 是 XHTML 标签，没有兼容问题</p>
<p>@import 是在 css2.1 中提出的，不支持低版本的浏览器</p>
<p>（4）改变样式</p>
<p>link 的标签是 DOM 元素，支持使用 JavaScript 控制 DOM 和修改样式</p>
<p>@import 是一种方法，不支持控制 DOM 和修改元素</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/" class="post-title-link" itemprop="url">JS：map、filter、reduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-22 09:28:46 / 修改时间：09:28:49" itemprop="dateCreated datePublished" datetime="2020-03-22T09:28:46+08:00">2020-03-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、map"><a href="#1、map" class="headerlink" title="1、map"></a>1、map</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((item, index, <span class="built_in">array</span>)=&gt; item = item+<span class="number">1</span>)  =&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><code>map</code>的回调函数可接受三个参数，遍历原数组，对每个元素进行操作，返回一个新数组。</p>
<h3 id="2、filter"><a href="#2、filter" class="headerlink" title="2、filter"></a>2、filter</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((item, index, <span class="built_in">array</span>)=&gt; item != <span class="number">2</span>)  =&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><code>filter</code> 的回调函数也可以接受三个参数，在遍历原数组事，将返回值为 true 的元素放在新数组中，返回新数组。</p>
<h3 id="3、reduce"><a href="#3、reduce" class="headerlink" title="3、reduce"></a>3、reduce</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((acc, current) =&gt; acc+ current, <span class="number">0</span>)  =&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><code>reduce</code>接收两个参数，分别是回调函数和初始值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/" class="post-title-link" itemprop="url">JS：call、apply、bind</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-15 16:11:25" itemprop="dateCreated datePublished" datetime="2019-10-15T16:11:25+08:00">2019-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 09:26:16" itemprop="dateModified" datetime="2020-03-22T09:26:16+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、call"><a href="#一、call" class="headerlink" title="一、call"></a>一、call</h2><p>改变函数的 this 指向，<code>call()</code> 第一个参数为 this 要指定的对象，后面可以<strong>接收多个参数列表 **，会</strong>立即调用** 。</p>
<p><strong>注：</strong> 如果第一个参数为空|null|undefined，则 this 指向 window。</p>
<h4 id="手撕-call"><a href="#手撕-call" class="headerlink" title="手撕 call"></a>手撕 call</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = functionl(context)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="built_in">arguments</span>].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<ol>
<li>context 为可选参数，如果不传的话默认上下文为 window；</li>
<li>给 context 创建一个 fn 属性，并将值设置为需要调用的函数（因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来）；</li>
<li>调用函数并将对象上的函数删除</li>
</ol>
<h2 id="二、apply"><a href="#二、apply" class="headerlink" title="二、apply"></a>二、apply</h2><p>和 call 一样，唯一的区别就是调用参数的形式不同，apply 传入的是数组。</p>
<h4 id="手撕-apply"><a href="#手撕-apply" class="headerlink" title="手撕 apply"></a>手撕 apply</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = functionl(context)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">//处理参数和call有区别</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、bind"><a href="#三、bind" class="headerlink" title="三、bind"></a>三、bind</h2><p>bind 也是为了改变函数体内部 this 的指向，返回一个函数，稍后调用。</p>
<h4 id="手撕-bind"><a href="#手撕-bind" class="headerlink" title="手撕 bind"></a>手撕 bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//因为返回了一个函数，我们可以new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args,...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context,args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h2><h3 id="1、call、apply、bind-的区别"><a href="#1、call、apply、bind-的区别" class="headerlink" title="1、call、apply、bind 的区别"></a>1、call、apply、bind 的区别</h3><ul>
<li>call 和 apply 改变了函数的 this 指向后便立即执行；</li>
<li>bind 则是返回改变了上下文之后的一个函数，便于稍后调用。</li>
</ul>
<h3 id="2、call、apply-的区别"><a href="#2、call、apply-的区别" class="headerlink" title="2、call、apply 的区别"></a>2、call、apply 的区别</h3><p>call 和 apply 的第一个参数都是 this 要指向的对象，它们两个不同的地方在于第二个参数之后的参数。</p>
<ul>
<li>call 从第二个参数开始以参数列表的形式展现；</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fn</span>.call(obj, arg<span class="number">1</span>, arg<span class="number">2</span>, arg<span class="number">3</span>...);</span><br></pre></td></tr></table></figure>

<ul>
<li>apply 将除第一个以外的所有参数都放在一个数组中作为第二个参数。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fn</span><span class="selector-class">.apply</span>(<span class="selector-tag">obj</span>, <span class="selector-attr">[arg1, arg2, arg3...]</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">JS：原型、原型链继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-15 19:39:17" itemprop="dateCreated datePublished" datetime="2019-10-15T19:39:17+08:00">2019-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 16:01:38" itemprop="dateModified" datetime="2020-03-21T16:01:38+08:00">2020-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p><strong>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</strong></p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用 new 关键字来调用</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = gender</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>, <span class="string">&quot;雄&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/3174701-1a20d86bf6856c95?imageMogr2/auto-orient/strip%7CimageView2/2/w/587/format/webp"></p>
<p>每创建一个 c<code>Person 构造函数，在 Person 构造函数中，为每一个对象都添加了一个 sayName 方法，也就是说构造函数每执行一次就会创建一个新的 sayName 方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行 10000 次就会创建 10000 个新的方法，而 10000 个方法都是一摸一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(</code>prototype`)</p>
<h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><p><strong>在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3174701-2dd95188a8f6b19e?imageMogr2/auto-orient/strip%7CimageView2/2/w/467/format/webp"></p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><h3 id="1-proto-和constructor"><a href="#1-proto-和constructor" class="headerlink" title="1.__proto__和constructor"></a>1.<code>__proto__</code>和<code>constructor</code></h3><p><strong>每一个对象数据类型(普通的对象、实例、prototype……)也天生自带一个属性</strong>proto<strong>，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性 constructor, 它指向函数对象。</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person()</span> &#123;&#125;</span><br><span class="line">var person = <span class="keyword">new</span> <span class="constructor">Person()</span></span><br><span class="line">console.log(person.__proto__<span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype)<span class="comment">//true</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.constructor===Person)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">person</span>)</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3174701-9a3de0b501161c07?imageMogr2/auto-orient/strip%7CimageView2/2/w/530/format/webp"></p>
<h3 id="2-何为原型链"><a href="#2-何为原型链" class="headerlink" title="2.何为原型链"></a>2.何为原型链</h3><p><strong>在 JavaScript 中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在 JavaScript 中是通过 prototype 对象指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong>。</p>
<p>举例说明:person → Person → Object ，普通人继承人类，人类继承对象类</p>
<p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。</strong></p>
<p>我们可以使用对象的<code>hasOwnProperty()</code>来检查对象自身中是否含有该属性；使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span><span class="keyword">in</span> person)<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>person 实例中没有 a 这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 Person.prototype 中查找，很幸运地得到 a 的值为 123。那假如 <code>person.__proto__</code>中也没有该属性，又该如何查找？</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层 Object 为止。<strong>Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上没有</strong>proto<strong>这个属性。</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3174701-18a76d28c0a9ea1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/521/format/webp" alt="img"></p>
<h2 id="四、原型链继承"><a href="#四、原型链继承" class="headerlink" title="四、原型链继承"></a>四、原型链继承</h2><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p>子类的原型是父类原型的一个实例对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、借用构造函数"><a href="#2、借用构造函数" class="headerlink" title="2、借用构造函数"></a>2、借用构造函数</h3><p>在子类的构造函数中使用 call()调用父类的构造函数。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、原型链继承-借用构造函数-组合继承"><a href="#3、原型链继承-借用构造函数-组合继承" class="headerlink" title="3、原型链继承+借用构造函数=组合继承"></a>3、原型链继承+借用构造函数=组合继承</h3><p>通过在子类的构造函数中调用父类型的构造函数，保留传参的优点，此外通过将父类的实例对象作为子类的原型，满足函数复用。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype.constructor = <span class="constructor">Student()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、组合继承优化-1"><a href="#4、组合继承优化-1" class="headerlink" title="4、组合继承优化 1"></a>4、组合继承优化 1</h3><p>子类的构造函数中调用父类的构造函数，子类的原型和父类的原型指向同一对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype;</span><br></pre></td></tr></table></figure>

<h3 id="5、组合继承优化-2"><a href="#5、组合继承优化-2" class="headerlink" title="5、组合继承优化 2"></a>5、组合继承优化 2</h3><p>子类的构造函数中调用父类的构造函数，使用 var B = Object.create(A)，以 A 为对象为原型生成 B。这样 B 就继承了 A 的所有属性和方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype.constructor = Student;</span><br></pre></td></tr></table></figure>

<h3 id="6：ES6-中-class-继承"><a href="#6：ES6-中-class-继承" class="headerlink" title="6：ES6 中 class 继承"></a>6：ES6 中 class 继承</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    constructor(name, age, sex)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bb091a7e51d450e8477d9ba">JavaScript 常见的六种继承方式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/" class="post-title-link" itemprop="url">JS：typeof、instanceof以及Object.prototyte.toString.call()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-13 14:11:06" itemprop="dateCreated datePublished" datetime="2019-10-13T14:11:06+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 14:57:30" itemprop="dateModified" datetime="2020-03-21T14:57:30+08:00">2020-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>number、string、Boolean、undefined、null、Symbol</p>
<h3 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h3><p>Object(Array、Function、Date。。。)</p>
<h3 id="3、基本数据类型和引用数据类型的区别"><a href="#3、基本数据类型和引用数据类型的区别" class="headerlink" title="3、基本数据类型和引用数据类型的区别"></a>3、基本数据类型和引用数据类型的区别</h3><p>（1）基本数据类型的值不可变，引用数据类型的值可变；</p>
<p>（2）基本数据类型存储的是值，引用数据类型存储的是地址（指针）；</p>
<p>（3）基本数据类型的比较是值得比较，引用数据类型的比较是地址的比较；</p>
<p>（4）基本数据类型的值保存在栈中；引用数据类型的值保存在堆中，指针保存在栈中，这个指针指向堆中的值。</p>
<h2 id="二、判断数据类型的方法"><a href="#二、判断数据类型的方法" class="headerlink" title="二、判断数据类型的方法"></a>二、判断数据类型的方法</h2><h3 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h3><ul>
<li><strong>对于基本数据类型，除了 null 输出为 object，其他的都是正确的类型；</strong></li>
<li><strong>对于引用数据类型，除了 function 输出为 function，其他的都是 object</strong></li>
</ul>
<h4 id="（1）原理"><a href="#（1）原理" class="headerlink" title="（1）原理"></a>（1）原理</h4><p>js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息</p>
<ul>
<li>000：对象</li>
<li>010：浮点数</li>
<li>100：字符创</li>
<li>110：布尔</li>
<li>1：整数</li>
<li>null：所有机器码均为 0</li>
<li>undefined：用-2^30 整数来表示</li>
</ul>
<p><strong>因为 null 的所有机器码都为 0，所以 typeof 就把他当做了对象来看待</strong></p>
<h4 id="（2）实现"><a href="#（2）实现" class="headerlink" title="（2）实现"></a>（2）实现</h4><p>typeof 可以判断一个变量的类型，</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>               =&gt;  <span class="string">&quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;1&quot;</span>             =&gt;  <span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>       =&gt;  <span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>            =&gt;  <span class="string">&quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()        =&gt;  <span class="string">&quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>            =&gt;  <span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []              =&gt;  <span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;              =&gt;  <span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> a()&#123;&#125;  =&gt;  <span class="string">&quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、instanceof</h3><p>语法：<code>数据 instanceof 数据类型</code>，返回 true 或 false</p>
<h4 id="（1）作用"><a href="#（1）作用" class="headerlink" title="（1）作用"></a>（1）作用</h4><ul>
<li><strong>判断一个实例是否属于某种类型；</strong></li>
<li><strong>判断一个实例是否是其父类型或者祖先类型的实例。</strong></li>
</ul>
<h4 id="（2）原理"><a href="#（2）原理" class="headerlink" title="（2）原理"></a>（2）原理</h4><p>instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败则返回**false **</p>
<h4 id="（3）实现"><a href="#（3）实现" class="headerlink" title="（3）实现"></a>（3）实现</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>             =&gt;  <span class="literal">true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>            =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>            =&gt; <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>() <span class="keyword">instanceof</span> <span class="built_in">String</span>  =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>             =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">function</span> b()&#123;&#125;</span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Function</span>           =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Object-prototype-toString-call"><a href="#3、Object-prototype-toString-call" class="headerlink" title="3、Object.prototype toString.call()"></a>3、Object.prototype toString.call()</h3><p>语法：<code>Object.prototype.toString.call(数据)</code>返回<code>[object 数据类型]</code></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)            =&gt;  <span class="string">&quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])            =&gt;  <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">function</span>()&#123;&#125;)  =&gt;  <span class="string">&quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>)            =&gt;  <span class="string">&quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)             =&gt;  <span class="string">&quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)          =&gt;  <span class="string">&quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)          =&gt;  <span class="string">&quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)     =&gt; <span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call()              =&gt; <span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>())    =&gt;  <span class="string">&quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/at/</span>)          =&gt;  <span class="string">&quot;[object RegExp]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、类型转换"><a href="#三、类型转换" class="headerlink" title="三、类型转换"></a>三、类型转换</h2><h3 id="1、类型转换"><a href="#1、类型转换" class="headerlink" title="1、类型转换"></a>1、类型转换</h3><table>
<thead>
<tr>
<th>原始值</th>
<th align="center">转换目标</th>
<th align="right">结果</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td align="center">Boolean</td>
<td align="right">除了 0、-0、NaN 都为 true</td>
</tr>
<tr>
<td>string</td>
<td align="center">Boolean</td>
<td align="right">除了空串都为 true</td>
</tr>
<tr>
<td>undefined、null</td>
<td align="center">Boolean</td>
<td align="right">false</td>
</tr>
<tr>
<td>引用类型</td>
<td align="center">Boolean</td>
<td align="right">true</td>
</tr>
<tr>
<td>number</td>
<td align="center">string</td>
<td align="right">5=&gt;’5’</td>
</tr>
</tbody></table>
<p>| Boolean、函数<br>、symbol |string |’true’ |<br>|数组 |string |[1,2]=&gt;’1,2’ |<br>|对象 | string|’[object Object]’ |<br>|string |number |’1’=&gt;1,’a’=&gt;NaN |<br>|数组 |number |空数组=&gt;0,存在一个元素且为数字=&gt;数字,其他=&gt;NaN |<br>| null|number |0 |<br>|除了数组的引用类型 |number | NaN|<br>|symbol | number|报错 |</p>
<h3 id="2、四则运算"><a href="#2、四则运算" class="headerlink" title="2、四则运算"></a>2、四则运算</h3><ul>
<li><p>加法运算</p>
<ul>
<li>其中一方为字符串，会把另外一方也转成字符串；</li>
<li>如果一方不是字符串或数字，将它转换为数字或字符串；</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + &#x27;<span class="number">1</span>&#x27; =&gt; &#x27;<span class="number">11</span>&#x27;</span><br><span class="line">true + true =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] =&gt;&#x27;<span class="number">41</span>,<span class="number">2</span>,<span class="number">3</span>&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了加法以外，只要其中一方是数字，另一方也转成数字。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ajavascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ajavascript/" class="post-title-link" itemprop="url">总结：javascript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-24 21:23:10" itemprop="dateCreated datePublished" datetime="2019-10-24T21:23:10+08:00">2019-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 18:00:05" itemprop="dateModified" datetime="2020-03-12T18:00:05+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、数据类型及检测"><a href="#一、数据类型及检测" class="headerlink" title="一、数据类型及检测"></a>一、数据类型及检测</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/">参见总结：JS：typeof、instanceof 以及 Object.prototyte.toString.call()</a></p>
<h2 id="二、原型与原型链、继承"><a href="#二、原型与原型链、继承" class="headerlink" title="二、原型与原型链、继承"></a>二、原型与原型链、继承</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/">参见总结：JS：原型、原型链继承</a></p>
<h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><p>对于闭包，我的理解就是当某个函数 A 被调用时，这个函数 A 可以访问它定义时的作用域中的变量。</p>
<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在 JavaScript 中，函数即闭包，只有函数才会产生作用域。</p>
<p>闭包有 3 个特性：</p>
<ol>
<li>函数嵌套函数；</li>
<li>在函数内部可以引用外部的参数和变量；</li>
<li>参数和变量不会以垃圾回收机制回收。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006875662">JavaScript 闭包</a></p>
<h2 id="四、浅拷贝和深拷贝"><a href="#四、浅拷贝和深拷贝" class="headerlink" title="四、浅拷贝和深拷贝"></a>四、浅拷贝和深拷贝</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">参见总结：JS：赋值、深拷贝和浅拷贝</a></p>
<h2 id="五、防抖和节流"><a href="#五、防抖和节流" class="headerlink" title="五、防抖和节流"></a>五、防抖和节流</h2><p>防抖：事件被触发 n 秒之后再执行回调，如果在这段时间之内又被触发，则重新计时。</p>
<p>节流：规定在单位时间之内只能触发一次，如果触发了多次只有一次生效。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8de829f265da43623c4261">7 分钟理解 JS 的节流、防抖及使用场景</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c87b54ce51d455f7943dddb#chapter-three-one">2019 面试准备 - JS 防抖与节流</a></p>
<h2 id="六、数组方法、数组去重"><a href="#六、数组方法、数组去重" class="headerlink" title="六、数组方法、数组去重"></a>六、数组方法、数组去重</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/14/JS%EF%BC%9A%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">参见总结：JS：数组方法</a></p>
<p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/16/JS%EF%BC%9A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/">参见总结：JS：数组去重</a></p>
<h2 id="七、作用域和作用域链"><a href="#七、作用域和作用域链" class="headerlink" title="七、作用域和作用域链"></a>七、作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去，也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p>ES6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域</p>
<ul>
<li><strong>全局作用域</strong>：在代码中任何地方都能访问到，比如最外层函数和在最外层函数外面定义的变量、所有未定义直接赋值的变量、所有 window 对象的属性</li>
<li><strong>函数作用域</strong> ：声明在函数里面的变量 ，只在固定的代码片段内能访问到</li>
<li>**块级作用域 **：可通过 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问，所声明的变量不会提升到代码块顶部，禁止重复声明，如在一个函数内部、在一个代码块（用一对花括号包裹）内部</li>
</ul>
<p><strong>块语句（大括号“{}”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，他们不会创建一个新的作用域。</strong></p>
<p><strong>作用域在定义时就确定，并且不会改变；执行上下文在运行时确定，随时可能改变。</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c8290455188257e5d0ec64f">深入理解 JavaScript 作用域和作用域链</a></p>
<h2 id="八、this-的指向和-new-的过程"><a href="#八、this-的指向和-new-的过程" class="headerlink" title="八、this 的指向和 new 的过程"></a>八、this 的指向和 new 的过程</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/15/ES6%EF%BC%9Athis/">参见总结：ES6：this</a></p>
<h2 id="九、JavaScript-有哪些垃圾回收机制？"><a href="#九、JavaScript-有哪些垃圾回收机制？" class="headerlink" title="九、JavaScript 有哪些垃圾回收机制？"></a>九、JavaScript 有哪些垃圾回收机制？</h2><ol>
<li><p>标记清除（mark and sweep）</p>
<p>这是 JavaScript 最常见的垃圾回收方式。当变量进入执行环境的时候,比如在函数中声明一个变量，垃圾回收器将其标记为”进入环境”。当变量离开环境的时候（函数执行结束），将其标记为“离开环境”。</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量，以及被环境中变量所引用的变量（闭包）的标记。在完成这些之后仍然存在的标记就是要删除的变量。</p>
</li>
<li><p>引用计数</p>
<p>在低版本的 IE 中经常发生内存泄漏，很多时候就是因为它采用引用计数的方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就加 1,。如果该变量的值变成另外一个，则这个值得引用次数减 1，当这个值得引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问.因此，可以将它占用的空间回收，这样垃圾回收器会在运行的时候清理引用次数为 0 的值占用的空间。</p>
<p>在 IE 中虽然 JavaScript 对象通过标记清除方式进行垃圾回收，但是 BOM 与 DOM 对象是引用计数的方式回收垃圾的。也就是说，只要涉及 BOM 和 DOM，就会出现循环引用问题。</p>
</li>
</ol>
<h2 id="十、列举几种类型的-DOM-节点"><a href="#十、列举几种类型的-DOM-节点" class="headerlink" title="十、列举几种类型的 DOM 节点"></a>十、列举几种类型的 DOM 节点</h2><ul>
<li>整个文档是一个文档（Document）节点</li>
<li>每个 HTML 标签是一个元素（Element）节点</li>
<li>每一个 HTML 属性是一个属性（Attribute）节点</li>
<li>包含在 HTML 元素中的文本是文本（Text）节点</li>
</ul>
<h2 id="十一、谈谈-script-标签中-defer-和-async-属性的区别"><a href="#十一、谈谈-script-标签中-defer-和-async-属性的区别" class="headerlink" title="十一、谈谈 script 标签中 defer 和 async 属性的区别"></a>十一、谈谈 script 标签中 defer 和 async 属性的区别</h2><ol>
<li>defer 属性规定是否延迟执行脚本，直到页面加载为止。async 属性规定脚本一旦可用，就异步执行；</li>
<li>defer 并行加载 JavaScript 文件，会按照页面上 script 标签的顺序执行。async 并行加载 JavaScript 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行。</li>
</ol>
<h2 id="十二、encodeURI-和-decodeURI-的作用是什么？"><a href="#十二、encodeURI-和-decodeURI-的作用是什么？" class="headerlink" title="十二、encodeURI()和 decodeURI()的作用是什么？"></a>十二、encodeURI()和 decodeURI()的作用是什么？</h2><p>encodeURI()用于将 URL 转换为十六进制编码，而 decodeURI()用于将编码的 URL 转换成正常的 URL。</p>
<h2 id="十三、为什么不建议在-JavaScript-中使用-innerHTML？"><a href="#十三、为什么不建议在-JavaScript-中使用-innerHTML？" class="headerlink" title="十三、为什么不建议在 JavaScript 中使用 innerHTML？"></a>十三、为什么不建议在 JavaScript 中使用 innerHTML？</h2><p>通过 innerHTML 修改内容，每次都会刷新，因此很慢。在 innerHTML 中没有验证的机会，因此更容易在文档中插入错误代码，使网页不稳定。</p>
<h2 id="十四、在-DOM-操作中怎样创建、添加、移除、替换、插入和查找节点？"><a href="#十四、在-DOM-操作中怎样创建、添加、移除、替换、插入和查找节点？" class="headerlink" title="十四、在 DOM 操作中怎样创建、添加、移除、替换、插入和查找节点？"></a>十四、在 DOM 操作中怎样创建、添加、移除、替换、插入和查找节点？</h2><ol>
<li>创建节点</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">createDocumentFragment</span><span class="params">()</span></span> <span class="comment">// 创建一个DOM片段</span></span><br><span class="line"><span class="function"><span class="title">createElement</span><span class="params">()</span></span>  <span class="comment">//创建一个具体的元素</span></span><br><span class="line"><span class="function"><span class="title">createTextNode</span><span class="params">()</span></span>  <span class="comment">//创建一个文本节点</span></span><br></pre></td></tr></table></figure>

<p>2.添加、移除、替换、插入节点</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">appendChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">removeChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">replaceChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">insertBefore</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查找节点</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getElementByTagName</span><span class="params">()</span></span>  <span class="comment">//通过标签名称查找节点</span></span><br><span class="line"><span class="function"><span class="title">getElementByName</span><span class="params">()</span></span>  <span class="comment">//通过元素的name属性查找节点（IE容错能力较强，会得到一个数组，其中包括id等于name值得节点）</span></span><br><span class="line"><span class="function"><span class="title">getElementById</span><span class="params">()</span></span>  <span class="comment">//通过元素Id查找节点，具有唯一值</span></span><br></pre></td></tr></table></figure>

<h2 id="十五、null-和-undefined-的区别是什么？"><a href="#十五、null-和-undefined-的区别是什么？" class="headerlink" title="十五、null 和 undefined 的区别是什么？"></a>十五、null 和 undefined 的区别是什么？</h2><p>null 是一个表示“无”的对象，转为数值时为 0；undefined 是一个表示“无”的原始值，转为数值时为 NaN。</p>
<p>当声明的变量还未初始化时，变量的默认值为 undefined。</p>
<p>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p>undefined 表示“缺少值”，即此处应该有一个值，但是还没有定义，典型用法是：</p>
<ol>
<li>如果变量声明了，但是没有赋值，它就等于 undefined；</li>
<li>当调用函数时，如果没有提供应该提供的参数，该参数就等于 undefined；</li>
<li>如果对象没有赋值，该属性的值为 undefined；</li>
<li>当函数没有返回值时，默认返回 undefined。</li>
</ol>
<p>null 表示“没有对象”，即此处不应该有值，典型用法是：</p>
<ol>
<li>作为函数的参数，表示该函数的参数不是对象；</li>
<li>作为对象原型链的终点。</li>
</ol>
<h2 id="十六、JavaScript-延迟加载的方式有哪些？"><a href="#十六、JavaScript-延迟加载的方式有哪些？" class="headerlink" title="十六、JavaScript 延迟加载的方式有哪些？"></a>十六、JavaScript 延迟加载的方式有哪些？</h2><p>包括 defer 和 async，动态创建 DOM（创建 script，插入 DOM 中，加载完毕后回调，按需异步载入 JavaScript）。</p>
<h2 id="十七、call、apply、bind"><a href="#十七、call、apply、bind" class="headerlink" title="十七、call、apply、bind"></a>十七、call、apply、bind</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/">参见总结：JS：call、apply、bind</a></p>
<h2 id="十八、哪些操作会造成内存泄漏？"><a href="#十八、哪些操作会造成内存泄漏？" class="headerlink" title="十八、哪些操作会造成内存泄漏？"></a>十八、哪些操作会造成内存泄漏？</h2><p>内存泄漏指不再拥有或需要任何对象（数据）之后，它们仍然存在于内存中。</p>
<p><strong>提示：</strong> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的唯一引用是循环的，那么该对象占用的内存立即被回收。</p>
<p>如果 settimeout 的第一个参数使用字符串而非函数，会引发内存泄漏。</p>
<p>闭包、控制台日志，循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）等会造成内存泄漏。</p>
<h2 id="十九、列举-IE-与-Firefox-的不同之处。"><a href="#十九、列举-IE-与-Firefox-的不同之处。" class="headerlink" title="十九、列举 IE 与 Firefox 的不同之处。"></a>十九、列举 IE 与 Firefox 的不同之处。</h2><p>不同之处如下。</p>
<ol>
<li>IE 支持 currentStyle，Firefox 使用 getComputStyle；</li>
<li>IE 使用 innerText，Firefox 使用 textContent;</li>
<li>在透明度过滤镜方面，IE 使用 filter:alpha(opacity = num); Firefox 使用-moz-opacity:num；</li>
<li>在事件方面，IE 使用 attachEvent；Firefox 使用 addEventListener；</li>
<li>对于鼠标位置：IE 使用 event.clientX；Firefox 使用 event.pageX；</li>
<li>IE 使用 event.srcElement；Firefox 使用 event.target。</li>
<li>要消除 list 圆点，IE 中仅需使 margin：0 即可达到最终效果，Firefox 中需要设置 margin：0，padding：0，list-style：none；</li>
<li>css 圆角：IE7 以下不支持圆角。</li>
</ol>
<h2 id="二十、如何实现异步编程？"><a href="#二十、如何实现异步编程？" class="headerlink" title="二十、如何实现异步编程？"></a>二十、如何实现异步编程？</h2><ol>
<li>通过回调函数，优点是简单、容易理解和部署；缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程混乱，而且每个任务只能指定一个回调函数。</li>
<li>通过事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化；缺点是整个程序都要变成事件驱动型，运行流程会变得恨不清晰。</li>
<li>采用发布/订阅方式，性质与“事件监听”类似，但是明显优于后者；</li>
<li>通过 Promise 对象实现，Promise 对象是 CommonJS 工作组提出的一种规范，旨在为异步编程提供统一接口。它的思想是，每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。</li>
</ol>
<h2 id="二十一、请解释一下-JavaScript-的同源策略。"><a href="#二十一、请解释一下-JavaScript-的同源策略。" class="headerlink" title="二十一、请解释一下 JavaScript 的同源策略。"></a>二十一、请解释一下 JavaScript 的同源策略。</h2><p>同源策略是客户端脚本（尤其是 JavaScript）的重要安全度量标准。它最早出自 Netscape Navigator 2.0，目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是协议、域名、端口相同。同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h2 id="二十二、为什么要有同源限制？"><a href="#二十二、为什么要有同源限制？" class="headerlink" title="二十二、为什么要有同源限制？"></a>二十二、为什么要有同源限制？</h2><p>我们举例说明，比如一个黑客，他利用 Iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名、密码登录时，他的页面就可以通过 JavaScript 读取到你表单上 input 的内容，这样黑客就会轻松得到你的用户名和密码。</p>
<h2 id="二十三、map-filter-和-reduce"><a href="#二十三、map-filter-和-reduce" class="headerlink" title="二十三、map,filter 和 reduce"></a>二十三、map,filter 和 reduce</h2><p><a href="">参见总结：JS：map、filter、reduce</a></p>
<h2 id="二十四、前端模块化"><a href="#二十四、前端模块化" class="headerlink" title="二十四、前端模块化"></a>二十四、前端模块化</h2><p><a href="https://chajianyuan.github.io/2019/10/20/JS%EF%BC%9A%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">参见总结：JS：前端模块化</a></p>
<h2 id="二十五、数组方法"><a href="#二十五、数组方法" class="headerlink" title="二十五、数组方法"></a>二十五、数组方法</h2><p><a href="">参见总结：JS：数组方法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8/" class="post-title-link" itemprop="url">总结：浏览器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-24 21:31:05" itemprop="dateCreated datePublished" datetime="2019-10-24T21:31:05+08:00">2019-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-28 16:47:52" itemprop="dateModified" datetime="2020-02-28T16:47:52+08:00">2020-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、一个-URL-从输入到显示的过程"><a href="#一、一个-URL-从输入到显示的过程" class="headerlink" title="一、一个 URL 从输入到显示的过程"></a>一、一个 URL 从输入到显示的过程</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/">参见总结：浏览器：一个 URL 从输入到显示的过程</a></p>
<h2 id="二、重绘和回流"><a href="#二、重绘和回流" class="headerlink" title="二、重绘和回流"></a>二、重绘和回流</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/">参见总结：浏览器：重绘和回流</a></p>
<h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5cb33660e51d456e811d2687">JavaScript 中的垃圾回收和内存泄漏</a></p>
<h2 id="四、浏览器兼容性"><a href="#四、浏览器兼容性" class="headerlink" title="四、浏览器兼容性"></a>四、浏览器兼容性</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/59a3f2fe6fb9a0249471cbb4">浏览器兼容问题</a></p>
<h2 id="五、浏览器缓存机制"><a href="#五、浏览器缓存机制" class="headerlink" title="五、浏览器缓存机制"></a>五、浏览器缓存机制</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">参见总结：浏览器：浏览器缓存机制</a></p>
<h2 id="六、事件机制"><a href="#六、事件机制" class="headerlink" title="六、事件机制"></a>六、事件机制</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">参见总结：浏览器：事件机制</a></p>
<h2 id="七、事件循环机制"><a href="#七、事件循环机制" class="headerlink" title="七、事件循环机制"></a>七、事件循环机制</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEeventloop/">参见总结：浏览器：事件循环 Eventloop</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">浏览器：浏览器缓存机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-20 08:09:55" itemprop="dateCreated datePublished" datetime="2019-10-20T08:09:55+08:00">2019-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 17:28:47" itemprop="dateModified" datetime="2020-02-27T17:28:47+08:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、缓存位置"><a href="#一、缓存位置" class="headerlink" title="一、缓存位置"></a>一、缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有<strong>优先级</strong>，当依次查找缓存且都没有命中的时候，才会去请求网络</p>
<h3 id="1、Service-Worker"><a href="#1、Service-Worker" class="headerlink" title="1、Service Worker"></a>1、Service Worker</h3><p>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。</p>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。<strong>但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</strong></p>
<h3 id="2、Memory-Cache"><a href="#2、Memory-Cache" class="headerlink" title="2、Memory Cache"></a>2、Memory Cache</h3><p>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong> 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>
<p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677db8003dc8311?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="从内存中读取缓存"></p>
<p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p>
<p>先说结论，这是<strong>不可能</strong>的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 JS、HTML、CSS、图片等等。</p>
<ul>
<li>对于大文件来说，大概率是不存储在内存中的，反之优先</li>
<li>当前系统内存使用率高的话，文件优先存储进硬盘</li>
</ul>
<h3 id="3、Disk-Cache"><a href="#3、Disk-Cache" class="headerlink" title="3、Disk Cache"></a>3、Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></p>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p>
<h3 id="4、Push-Cache"><a href="#4、Push-Cache" class="headerlink" title="4、Push Cache"></a>4、Push Cache</h3><p>Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong></p>
<ul>
<li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>
<li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<h3 id="5、网络请求"><a href="#5、网络请求" class="headerlink" title="5、网络请求"></a>5、网络请求</h3><p>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</p>
<h2 id="二、缓存策略"><a href="#二、缓存策略" class="headerlink" title="二、缓存策略"></a>二、缓存策略</h2><p>通常浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>
<h3 id="1、强缓存"><a href="#1、强缓存" class="headerlink" title="1、强缓存"></a>1、强缓存</h3><p>强缓存可以通过设置两种 HTTP Header 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200。</p>
<h4 id="1-1-Expires"><a href="#1-1-Expires" class="headerlink" title="1.1 Expires"></a>1.1 Expires</h4><p><code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code></p>
<p><code>Expires</code> 是 HTTP/1 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> <strong>受限于本地时间</strong>，如果修改了本地时间，可能会造成缓存失效。</p>
<h4 id="1-2-Cache-control"><a href="#1-2-Cache-control" class="headerlink" title="1.2 Cache-control"></a>1.2 Cache-control</h4><p><code>Cache-control: max-age=30</code></p>
<p><code>Cache-Control</code> 出现于 HTTP/1.1，<strong>优先级高于 Expires</strong> 。该属性值表示资源会在 30 秒后过期，需要再次请求。</p>
<p><code>Cache-Control</code> <strong>可以在请求头或者响应头中设置</strong>，并且可以组合使用多种指令</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/6/1678234a1ed20487?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>从图中我们可以看到，我们可以将<strong>多个指令配合起来一起使用</strong>，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="常见指令作用"></p>
<h3 id="2、协商缓存"><a href="#2、协商缓存" class="headerlink" title="2、协商缓存"></a>2、协商缓存</h3><p>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：<code>Last-Modified</code>和 <code>ETag</code> 。</p>
<p>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/6/16782357baddf1c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h4 id="2-1-Last-Modified-和-If-Modified-Since"><a href="#2-1-Last-Modified-和-If-Modified-Since" class="headerlink" title="2.1 Last-Modified 和 If-Modified-Since"></a>2.1 Last-Modified 和 If-Modified-Since</h4><p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。</p>
<p>但是 <code>Last-Modified</code> 存在一些弊端：</p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li>
<li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>
</ul>
<p>因为以上这些弊端，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p>
<h4 id="2-2-ETag-和-If-None-Match"><a href="#2-2-ETag-和-If-None-Match" class="headerlink" title="2.2 ETag 和 If-None-Match"></a>2.2 ETag 和 If-None-Match</h4><p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高。</p>
<p>以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。<strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p>
<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c32ac69f265da6150649ec2">深入浅出浏览器缓存机制</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/" class="post-title-link" itemprop="url">浏览器：重绘和回流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-19 15:48:03" itemprop="dateCreated datePublished" datetime="2019-10-19T15:48:03+08:00">2019-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 16:42:16" itemprop="dateModified" datetime="2020-02-27T16:42:16+08:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<p><strong>回流必将引起重绘，重绘不一定会引起回流</strong></p>
<h2 id="一、回流（reflow）"><a href="#一、回流（reflow）" class="headerlink" title="一、回流（reflow）"></a>一、回流（<code>reflow</code>）</h2><p>当渲染树中部分或全部元素的尺寸、结构，或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p><strong>会导致回流的操作：</strong></p>
<ul>
<li>css 样式中的 display</li>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生变化</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或删除可见的 DOM 元素</li>
<li>激活 css 伪类（例如：hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p><strong>一些常用但会导致回流的属性和方法：</strong></p>
<ul>
<li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li>
<li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li>
<li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li>
<li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
<h2 id="二、重绘（Repaint）"><a href="#二、重绘（Repaint）" class="headerlink" title="二、重绘（Repaint）"></a>二、重绘（<code>Repaint</code>）</h2><p>当页面中元素样式的改变并不影响它在文档流中的位置时（如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<h2 id="三、如何避免"><a href="#三、如何避免" class="headerlink" title="三、如何避免"></a>三、如何避免</h2><h3 id="1、css"><a href="#1、css" class="headerlink" title="1、css"></a>1、css</h3><ul>
<li>避免使用<code>table</code>布局</li>
<li>尽可能在 DOM 树的最末端改变 class</li>
<li>避免设置多层内联样式</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li>
<li>避免使用 css 表达式</li>
</ul>
<h3 id="2、JavaScript"><a href="#2、JavaScript" class="headerlink" title="2、JavaScript"></a>2、JavaScript</h3><ul>
<li>避免频繁操作样式，最好一次性重写 style 属性，或将样式列表定义为 class 并一次性更改 class 属性</li>
<li>避免重复操作 DOM，创建一个<code>documentFragment</code>，在它上面应用所有 DOM 操作，最后再把它添加到文档中</li>
<li>可以先为元素设置<code>display:none</code>，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a9923e9518825558251c96a">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chajianyuan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chajianyuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
