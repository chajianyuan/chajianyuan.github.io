<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chajianyuan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"ZFO5FC3GGP","apiKey":"ebb197ff3f64dd809727fafc95ab1151","indexName":"test_NAME","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="查见原的博客">
<meta property="og:url" content="https://chajianyuan.github.io/page/6/index.html">
<meta property="og:site_name" content="查见原的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chajianyuan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chajianyuan.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>查见原的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="查见原的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">查见原的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">越努力，越幸运</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEeventloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEeventloop/" class="post-title-link" itemprop="url">浏览器：事件循环Eeventloop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-18 21:47:36" itemprop="dateCreated datePublished" datetime="2019-10-18T21:47:36+08:00">2019-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-24 20:23:18" itemprop="dateModified" datetime="2020-03-24T20:23:18+08:00">2020-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、线程和进程"><a href="#一、线程和进程" class="headerlink" title="一、线程和进程"></a>一、线程和进程</h2><p>javascript 是单线程的，也就是说同一个时间只能做一件事。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。如果浏览器同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程是删除这个节点，那浏览器应该以哪个线程为主呢？</p>
<h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><p>CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位），进程是指在系统中正在运行的一个应用程序，是系统资源分配的基本单位，在内存中有其完备的数据空间和代码空间，拥有完备的虚拟空间地址。一个进程所拥有的数据和变量只属于他自己</p>
<h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程），线程是进程内相对独立的可执行单元，所以也被称为轻量进程，是操作系统进行任务调度的基本单元。它与父进程的其他线程共享该进程所拥有的全部代码空间和全局变量，但拥有私有的局部变量</p>
<h3 id="3、联系"><a href="#3、联系" class="headerlink" title="3、联系"></a>3、联系</h3><p>一个进程至少拥有一个线程（主线程），一个线程必须有一个父进程。多个进程可以并发执行；一个线程可以创建或撤销另一个线程；同一个进程中的多个线程之间可以并发执行。</p>
<h3 id="4、进程和线程的区别"><a href="#4、进程和线程的区别" class="headerlink" title="4、进程和线程的区别"></a>4、进程和线程的区别</h3><ol>
<li>进程是资源分配和保护的基本单位，线程是处理器调度和分派的基本单位，程序执行的最小单元；</li>
<li>同一个进程中可以包含多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包含一个线程；</li>
<li>进程结束后，它所有的线程都将销毁，而线程的结束不会影响同个进程中其他线程的结束；</li>
<li>线程是轻量级的进程，它的创建和销毁所需时间和空间都比进程小很多，所有操作系统的执行功能都是创建线程去完成的；</li>
<li>线程有自己的私有属性 TCB，线程 id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块 PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志；<br>6 <strong>系统开销</strong>：在创建或撤销进程时，系统都要为它分配或回收资源，导致系统的开销明显大于创建或撤销线程时的开销；<br>7 <strong>资源管理</strong>：进程有独立的地址空间，一个进程崩溃后不会对其他进程产生影响，一个线程死掉会导致整个进程都死掉；<br>8 <strong>通信方式</strong>：进程间通信包括管道、系统 IPC（包括消息队列，信号量，共享存储）、SOCKET 等，进程间的通信方式同样适用于线程之间的通信，但是一个进程之间的多个线程使用全局变量通信更高效。</li>
</ol>
<h2 id="二、同步和异步"><a href="#二、同步和异步" class="headerlink" title="二、同步和异步"></a>二、同步和异步</h2><p>任务分为同步任务和异步任务</p>
<h3 id="1、同步任务"><a href="#1、同步任务" class="headerlink" title="1、同步任务"></a>1、同步任务</h3><p>如果在函数返回的时候，调用者就能够得到预期结果（即拿到了预期的返回值或者看到了预期的效果）</p>
<h3 id="2、异步任务"><a href="#2、异步任务" class="headerlink" title="2、异步任务"></a>2、异步任务</h3><p>如果在函数返回的时候，调用者还不能得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的</p>
<h4 id="异步详解"><a href="#异步详解" class="headerlink" title="异步详解"></a>异步详解</h4><p><strong>一个异步过程通常是</strong></p>
<ol>
<li>主线程发出一个异步请求，异步任务接到请求并告知主线程已经收到（异步函数返回）；</li>
<li>主线程可以继续执行后面的代码，同时异步操作开始执行；</li>
<li>执行完成后通知主线程；</li>
<li>主线程收到通知后，执行一定的动作（调用回调函数）</li>
</ol>
<p><strong>异步类型</strong></p>
<ol>
<li>普通事件，如 click、resize 等</li>
<li>资源加载，如 load、error 等</li>
<li>定时器，包括 setInterval、setTimeout 等</li>
</ol>
<p><strong>消息队列</strong></p>
<p>也叫任务队列、事件队列，总之是和异步任务相关的队列。</p>
<p>不管异步任务是什么时候开始执行的，只要异步操作执行完成，他就会被添加到消息队列中排队。</p>
<p>消息就是注册异步任务时添加的回调函数。</p>
<h2 id="三、事件循环"><a href="#三、事件循环" class="headerlink" title="三、事件循环"></a>三、事件循环</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/16740fa4cd9c6937?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><strong>步骤</strong></p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈</li>
<li>主线程之外，还存在一个“消息队列”，只要异步操作执行完成，就到消息队列中排队</li>
<li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务就结束了等待状态，进入到执行栈开始执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<p><strong>微任务</strong></p>
<p>process.nextTick，promise，MutationObserver，其中，process.nextTick 为 Node 独有</p>
<p><strong>宏任务</strong></p>
<p>script，setTimeout，setInterval，setImmediate，I/O，UI rendering</p>
<p>宏任务中包括了 script，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。</p>
<p>宏任务=&gt;所有微任务=&gt;宏任务，如下图：<br><img src="https://user-gold-cdn.xitu.io/2018/6/16/164081cfd8400f92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h3 id="面试题实践"><a href="#面试题实践" class="headerlink" title="面试题实践"></a>面试题实践</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span></span><br><span class="line">    resolve(3);</span><br><span class="line"><span class="javascript">  &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(res);</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：以上代码的打印顺序是什么？</strong></p>
<ol>
<li>先执行 script 同步代码，执行 new Promise 中的<code>console.log(2)</code>，then 后面的不执行，但是属于微任务，然后执行<code>console.log(4)</code>；</li>
<li>执行完 script 宏任务后，执行微任务<code>console.log(res)=&gt;3</code>;</li>
<li>执行另一个宏任务，定时器<code>console.log(1)</code>。</li>
</ol>
<p>所以最终输出的是 2,4,3,1。</p>
<h2 id="四、同步变异步"><a href="#四、同步变异步" class="headerlink" title="四、同步变异步"></a>四、同步变异步</h2><p>每一个消息完整的执行后，其他消息才会被执行，这点提供了一些优秀的特性，包括每当一个函数运行时，他不能被抢占，并且在其他代码运行完之前完全运行。</p>
<p>但是有一个缺点是当消息需要太长时间才能完成，Web 应用无法处理用户的交互，例如点击或滚动。</p>
<p>于是处理这种情况常见的优化就是同步变异步。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaohuochai/p/8527618.html#anchor4">深入理解 JavaScript 中的事件循环 event-loop</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">浏览器：事件机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-19 11:07:41" itemprop="dateCreated datePublished" datetime="2019-10-19T11:07:41+08:00">2019-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-24 16:46:09" itemprop="dateModified" datetime="2020-03-24T16:46:09+08:00">2020-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="1、事件触发三阶段"><a href="#1、事件触发三阶段" class="headerlink" title="1、事件触发三阶段"></a>1、事件触发三阶段</h2><ul>
<li>window 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处的时触发注册的事件</li>
<li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般会按照上面的顺序执行，但是也有例外，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>
<h2 id="2、注册事件"><a href="#2、注册事件" class="headerlink" title="2、注册事件"></a>2、注册事件</h2><p>通常使用<code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值是<code>false</code>， <code>useCapture</code>决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<ul>
<li><code>capture</code>：布尔值，和<code>useCapture</code>作用一样</li>
<li><code>once</code>：布尔值，值为<code>true</code>表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用<code>preventDefault</code></li>
</ul>
<p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用<code>stopPropagation</code>来阻止事件的进一步传播。通常我们认为<code>stopPropagation</code>是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code>同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="3、事件代理-事件委托"><a href="#3、事件代理-事件委托" class="headerlink" title="3、事件代理/事件委托"></a>3、事件代理/事件委托</h2><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#ul&#x27;</span>)</span></span><br><span class="line"><span class="javascript">	ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">	&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>事件代理的方式相较于直接给目标注册事件来说，有以下优点：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/13/css%EF%BC%9Aflex%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/13/css%EF%BC%9Aflex%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">css：flex布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-13 09:53:53" itemprop="dateCreated datePublished" datetime="2019-10-13T09:53:53+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 15:38:14" itemprop="dateModified" datetime="2020-03-22T15:38:14+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、容器的属性"><a href="#一、容器的属性" class="headerlink" title="一、容器的属性"></a>一、容器的属性</h2><h3 id="1、flex-direction"><a href="#1、flex-direction" class="headerlink" title="1、flex-direction"></a>1、flex-direction</h3><p>定义主轴的方向。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png"></p>
<h3 id="2、flex-wrap"><a href="#2、flex-wrap" class="headerlink" title="2、flex-wrap"></a>2、flex-wrap</h3><p>定义如果一行排不下，如何换行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: npwrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="nowrap"><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="wrap"><br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="wrap-reverse"></p>
<h3 id="3、flex-flow"><a href="#3、flex-flow" class="headerlink" title="3、flex-flow"></a>3、flex-flow</h3><p>flex-direction 和 flex-wrap 的简写，默认值为 row nowrap。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">  flex-flow：<span class="params">&lt;flex-direction&gt;</span> || <span class="params">&lt;flex-row&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、justify-content"><a href="#4、justify-content" class="headerlink" title="4、justify-content"></a>4、justify-content</h3><p>定义了项目在主轴上的对齐方式。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">box</span> &#123;</span><br><span class="line">  <span class="built_in">display</span>: flex;</span><br><span class="line">  justify-<span class="built_in">content</span>：flex-start | flex-end | <span class="built_in">center</span> | <span class="built_in">space</span>-between | <span class="built_in">space</span>-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png"></p>
<h3 id="5、align-items"><a href="#5、align-items" class="headerlink" title="5、align-items"></a>5、align-items</h3><p>定义了项目在交叉轴上如何对齐。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items：flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png"></p>
<h3 id="6、align-content"><a href="#6、align-content" class="headerlink" title="6、align-content"></a>6、align-content</h3><p>定义了多个项目在主轴上的对齐方式。如果只有一个项目则该属性不奏效。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-content：flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png"></p>
<h2 id="二、项目的属性"><a href="#二、项目的属性" class="headerlink" title="二、项目的属性"></a>二、项目的属性</h2><h3 id="1、order"><a href="#1、order" class="headerlink" title="1、order"></a>1、order</h3><p>定义项目的排列顺序。数值越小，排列越靠前，默认值为 0。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  order： <span class="params">&lt;integer&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png"></p>
<h3 id="2、flex-grow"><a href="#2、flex-grow" class="headerlink" title="2、flex-grow"></a>2、flex-grow</h3><p>定义项目的放大比例，默认值为 0，即如果存在剩余空间，也不放大。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex-grow：<span class="params">&lt;number&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png"></p>
<h3 id="3、flex-shrink"><a href="#3、flex-shrink" class="headerlink" title="3、flex-shrink"></a>3、flex-shrink</h3><p>定义了项目的缩小比例，默认值为 1，即如果空间不足，该项目将缩小。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex-shrink：<span class="params">&lt;number&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg"></p>
<h3 id="4、flex-basis"><a href="#4、flex-basis" class="headerlink" title="4、flex-basis"></a>4、flex-basis</h3><p>定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。默认值为 auto，即项目本身的大小。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex-basis：<span class="params">&lt;length&gt;</span> | auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、flex"><a href="#5、flex" class="headerlink" title="5、flex"></a>5、flex</h3><p>flex-grow，flex-shrink，flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="class">box </span>&#123;</span><br><span class="line"><span class="symbol">  display:</span> flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="class">item </span>&#123;</span><br><span class="line">  flex：none | <span class="params">&lt;flex-grow&gt;</span> <span class="params">&lt;flex-shrink&gt;</span>? || <span class="params">&lt;flex-basis&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、align-self"><a href="#6、align-self" class="headerlink" title="6、align-self"></a>6、align-self</h3><p>允许单个项目有不同于其他项目在交叉轴上的对齐方式，可以覆盖 align-items。默认为 auto，表示继承父元素的 align-items 属性，如果父元素没有 align-items 属性，则等同于 stretch。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  align-self：<span class="built_in">auto</span> | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png"></p>
<p>参照<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰的 Flex 布局教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/css%EF%BC%9Acss%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">css：css的引入方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-22 09:48:54 / 修改时间：09:48:57" itemprop="dateCreated datePublished" datetime="2020-03-22T09:48:54+08:00">2020-03-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、css-的引入方式有三种"><a href="#1、css-的引入方式有三种" class="headerlink" title="1、css 的引入方式有三种"></a>1、css 的引入方式有三种</h3><p>（1）行内式将样式写在元素的 style 属性里面</p>
<p>（2）内嵌式将样式写在&lt; style &gt;元素里面</p>
<p>（3）外链式指通过 link 标签引入 css 文件</p>
<h3 id="2、link-和-import-引入样式文件的区别"><a href="#2、link-和-import-引入样式文件的区别" class="headerlink" title="2、link 和@import 引入样式文件的区别"></a>2、link 和@import 引入样式文件的区别</h3><p>（1）加载资源的限制</p>
<p>link 是 XHTML 的标签，除了加载 css 文件之外，还能加载 RSS 等其他事务，如加载模板等；</p>
<p>@import 只能加载 css 文件</p>
<p>（2）加载方式</p>
<p>用 link 引用 css，在页面载入时同时加载，即同步加载；</p>
<p>用@import 引用 css，则需要等到网页完全载入后，再加载 css 文件，即异步加载</p>
<p>（3）兼容性</p>
<p>link 是 XHTML 标签，没有兼容问题</p>
<p>@import 是在 css2.1 中提出的，不支持低版本的浏览器</p>
<p>（4）改变样式</p>
<p>link 的标签是 DOM 元素，支持使用 JavaScript 控制 DOM 和修改样式</p>
<p>@import 是一种方法，不支持控制 DOM 和修改元素</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/JS%EF%BC%9Amap%E3%80%81filter%E3%80%81reduce/" class="post-title-link" itemprop="url">JS：map、filter、reduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-22 09:28:46 / 修改时间：09:28:49" itemprop="dateCreated datePublished" datetime="2020-03-22T09:28:46+08:00">2020-03-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、map"><a href="#1、map" class="headerlink" title="1、map"></a>1、map</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((item, index, <span class="built_in">array</span>)=&gt; item = item+<span class="number">1</span>)  =&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><code>map</code>的回调函数可接受三个参数，遍历原数组，对每个元素进行操作，返回一个新数组。</p>
<h3 id="2、filter"><a href="#2、filter" class="headerlink" title="2、filter"></a>2、filter</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((item, index, <span class="built_in">array</span>)=&gt; item != <span class="number">2</span>)  =&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><code>filter</code> 的回调函数也可以接受三个参数，在遍历原数组事，将返回值为 true 的元素放在新数组中，返回新数组。</p>
<h3 id="3、reduce"><a href="#3、reduce" class="headerlink" title="3、reduce"></a>3、reduce</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.map((acc, current) =&gt; acc+ current, <span class="number">0</span>)  =&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p><code>reduce</code>接收两个参数，分别是回调函数和初始值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/" class="post-title-link" itemprop="url">JS：call、apply、bind</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-15 16:11:25" itemprop="dateCreated datePublished" datetime="2019-10-15T16:11:25+08:00">2019-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-22 09:26:16" itemprop="dateModified" datetime="2020-03-22T09:26:16+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、call"><a href="#一、call" class="headerlink" title="一、call"></a>一、call</h2><p>改变函数的 this 指向，<code>call()</code> 第一个参数为 this 要指定的对象，后面可以<strong>接收多个参数列表 **，会</strong>立即调用** 。</p>
<p><strong>注：</strong> 如果第一个参数为空|null|undefined，则 this 指向 window。</p>
<h4 id="手撕-call"><a href="#手撕-call" class="headerlink" title="手撕 call"></a>手撕 call</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = functionl(context)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="built_in">arguments</span>].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<ol>
<li>context 为可选参数，如果不传的话默认上下文为 window；</li>
<li>给 context 创建一个 fn 属性，并将值设置为需要调用的函数（因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来）；</li>
<li>调用函数并将对象上的函数删除</li>
</ol>
<h2 id="二、apply"><a href="#二、apply" class="headerlink" title="二、apply"></a>二、apply</h2><p>和 call 一样，唯一的区别就是调用参数的形式不同，apply 传入的是数组。</p>
<h4 id="手撕-apply"><a href="#手撕-apply" class="headerlink" title="手撕 apply"></a>手撕 apply</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = functionl(context)&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">//处理参数和call有区别</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、bind"><a href="#三、bind" class="headerlink" title="三、bind"></a>三、bind</h2><p>bind 也是为了改变函数体内部 this 的指向，返回一个函数，稍后调用。</p>
<h4 id="手撕-bind"><a href="#手撕-bind" class="headerlink" title="手撕 bind"></a>手撕 bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">//返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//因为返回了一个函数，我们可以new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args,...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context,args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、区别"><a href="#四、区别" class="headerlink" title="四、区别"></a>四、区别</h2><h3 id="1、call、apply、bind-的区别"><a href="#1、call、apply、bind-的区别" class="headerlink" title="1、call、apply、bind 的区别"></a>1、call、apply、bind 的区别</h3><ul>
<li>call 和 apply 改变了函数的 this 指向后便立即执行；</li>
<li>bind 则是返回改变了上下文之后的一个函数，便于稍后调用。</li>
</ul>
<h3 id="2、call、apply-的区别"><a href="#2、call、apply-的区别" class="headerlink" title="2、call、apply 的区别"></a>2、call、apply 的区别</h3><p>call 和 apply 的第一个参数都是 this 要指向的对象，它们两个不同的地方在于第二个参数之后的参数。</p>
<ul>
<li>call 从第二个参数开始以参数列表的形式展现；</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fn</span>.call(obj, arg<span class="number">1</span>, arg<span class="number">2</span>, arg<span class="number">3</span>...);</span><br></pre></td></tr></table></figure>

<ul>
<li>apply 将除第一个以外的所有参数都放在一个数组中作为第二个参数。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fn</span><span class="selector-class">.apply</span>(<span class="selector-tag">obj</span>, <span class="selector-attr">[arg1, arg2, arg3...]</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">JS：原型、原型链继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-15 19:39:17" itemprop="dateCreated datePublished" datetime="2019-10-15T19:39:17+08:00">2019-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 16:01:38" itemprop="dateModified" datetime="2020-03-21T16:01:38+08:00">2020-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><p><strong>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</strong></p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，<strong>不同的是构造函数习惯上首字母大写</strong>。另外就是调用方式的不同，普通函数是直接调用，<strong>而构造函数需要使用 new 关键字来调用</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = gender</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">4</span>, <span class="string">&quot;雄&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(per);<span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/3174701-1a20d86bf6856c95?imageMogr2/auto-orient/strip%7CimageView2/2/w/587/format/webp"></p>
<p>每创建一个 c<code>Person 构造函数，在 Person 构造函数中，为每一个对象都添加了一个 sayName 方法，也就是说构造函数每执行一次就会创建一个新的 sayName 方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行 10000 次就会创建 10000 个新的方法，而 10000 个方法都是一摸一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(</code>prototype`)</p>
<h2 id="二、原型"><a href="#二、原型" class="headerlink" title="二、原型"></a>二、原型</h2><p><strong>在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</strong></p>
<p>让我们用一张图表示构造函数和实例原型之间的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3174701-2dd95188a8f6b19e?imageMogr2/auto-orient/strip%7CimageView2/2/w/467/format/webp"></p>
<p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<h2 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h2><h3 id="1-proto-和constructor"><a href="#1-proto-和constructor" class="headerlink" title="1.__proto__和constructor"></a>1.<code>__proto__</code>和<code>constructor</code></h3><p><strong>每一个对象数据类型(普通的对象、实例、prototype……)也天生自带一个属性</strong>proto<strong>，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性 constructor, 它指向函数对象。</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person()</span> &#123;&#125;</span><br><span class="line">var person = <span class="keyword">new</span> <span class="constructor">Person()</span></span><br><span class="line">console.log(person.__proto__<span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype)<span class="comment">//true</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype.constructor===Person)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>get<span class="constructor">PrototypeOf(<span class="params">person</span>)</span><span class="operator"> === </span><span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3174701-9a3de0b501161c07?imageMogr2/auto-orient/strip%7CimageView2/2/w/530/format/webp"></p>
<h3 id="2-何为原型链"><a href="#2-何为原型链" class="headerlink" title="2.何为原型链"></a>2.何为原型链</h3><p><strong>在 JavaScript 中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在 JavaScript 中是通过 prototype 对象指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong>。</p>
<p>举例说明:person → Person → Object ，普通人继承人类，人类继承对象类</p>
<p><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。</strong></p>
<p>我们可以使用对象的<code>hasOwnProperty()</code>来检查对象自身中是否含有该属性；使用<code>in</code>检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a)<span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span><span class="keyword">in</span> person)<span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>person 实例中没有 a 这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 <code>person.__proto__</code> ，也就是 Person.prototype 中查找，很幸运地得到 a 的值为 123。那假如 <code>person.__proto__</code>中也没有该属性，又该如何查找？</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层 Object 为止。<strong>Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上没有</strong>proto<strong>这个属性。</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3174701-18a76d28c0a9ea1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/521/format/webp" alt="img"></p>
<h2 id="四、原型链继承"><a href="#四、原型链继承" class="headerlink" title="四、原型链继承"></a>四、原型链继承</h2><h3 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h3><p>子类的原型是父类原型的一个实例对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2、借用构造函数"><a href="#2、借用构造函数" class="headerlink" title="2、借用构造函数"></a>2、借用构造函数</h3><p>在子类的构造函数中使用 call()调用父类的构造函数。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、原型链继承-借用构造函数-组合继承"><a href="#3、原型链继承-借用构造函数-组合继承" class="headerlink" title="3、原型链继承+借用构造函数=组合继承"></a>3、原型链继承+借用构造函数=组合继承</h3><p>通过在子类的构造函数中调用父类型的构造函数，保留传参的优点，此外通过将父类的实例对象作为子类的原型，满足函数复用。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="keyword">new</span> <span class="constructor">Person()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype.constructor = <span class="constructor">Student()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、组合继承优化-1"><a href="#4、组合继承优化-1" class="headerlink" title="4、组合继承优化 1"></a>4、组合继承优化 1</h3><p>子类的构造函数中调用父类的构造函数，子类的原型和父类的原型指向同一对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype;</span><br></pre></td></tr></table></figure>

<h3 id="5、组合继承优化-2"><a href="#5、组合继承优化-2" class="headerlink" title="5、组合继承优化 2"></a>5、组合继承优化 2</h3><p>子类的构造函数中调用父类的构造函数，使用 var B = Object.create(A)，以 A 为对象为原型生成 B。这样 B 就继承了 A 的所有属性和方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="constructor">Person(<span class="params">name</span>, <span class="params">age</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="constructor">Student(<span class="params">name</span>, <span class="params">age</span>, <span class="params">sex</span>)</span>&#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>call(this, name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype = <span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">Person</span>.</span></span>prototype);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Student</span>.</span></span>prototype.constructor = Student;</span><br></pre></td></tr></table></figure>

<h3 id="6：ES6-中-class-继承"><a href="#6：ES6-中-class-继承" class="headerlink" title="6：ES6 中 class 继承"></a>6：ES6 中 class 继承</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    constructor(name, age)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    constructor(name, age, sex)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5bb091a7e51d450e8477d9ba">JavaScript 常见的六种继承方式</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/" class="post-title-link" itemprop="url">JS：typeof、instanceof以及Object.prototyte.toString.call()</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-13 14:11:06" itemprop="dateCreated datePublished" datetime="2019-10-13T14:11:06+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-21 14:57:30" itemprop="dateModified" datetime="2020-03-21T14:57:30+08:00">2020-03-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h3><p>number、string、Boolean、undefined、null、Symbol</p>
<h3 id="2、引用数据类型"><a href="#2、引用数据类型" class="headerlink" title="2、引用数据类型"></a>2、引用数据类型</h3><p>Object(Array、Function、Date。。。)</p>
<h3 id="3、基本数据类型和引用数据类型的区别"><a href="#3、基本数据类型和引用数据类型的区别" class="headerlink" title="3、基本数据类型和引用数据类型的区别"></a>3、基本数据类型和引用数据类型的区别</h3><p>（1）基本数据类型的值不可变，引用数据类型的值可变；</p>
<p>（2）基本数据类型存储的是值，引用数据类型存储的是地址（指针）；</p>
<p>（3）基本数据类型的比较是值得比较，引用数据类型的比较是地址的比较；</p>
<p>（4）基本数据类型的值保存在栈中；引用数据类型的值保存在堆中，指针保存在栈中，这个指针指向堆中的值。</p>
<h2 id="二、判断数据类型的方法"><a href="#二、判断数据类型的方法" class="headerlink" title="二、判断数据类型的方法"></a>二、判断数据类型的方法</h2><h3 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a>1、typeof</h3><ul>
<li><strong>对于基本数据类型，除了 null 输出为 object，其他的都是正确的类型；</strong></li>
<li><strong>对于引用数据类型，除了 function 输出为 function，其他的都是 object</strong></li>
</ul>
<h4 id="（1）原理"><a href="#（1）原理" class="headerlink" title="（1）原理"></a>（1）原理</h4><p>js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息</p>
<ul>
<li>000：对象</li>
<li>010：浮点数</li>
<li>100：字符创</li>
<li>110：布尔</li>
<li>1：整数</li>
<li>null：所有机器码均为 0</li>
<li>undefined：用-2^30 整数来表示</li>
</ul>
<p><strong>因为 null 的所有机器码都为 0，所以 typeof 就把他当做了对象来看待</strong></p>
<h4 id="（2）实现"><a href="#（2）实现" class="headerlink" title="（2）实现"></a>（2）实现</h4><p>typeof 可以判断一个变量的类型，</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>               =&gt;  <span class="string">&quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;1&quot;</span>             =&gt;  <span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>       =&gt;  <span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>            =&gt;  <span class="string">&quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()        =&gt;  <span class="string">&quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>            =&gt;  <span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []              =&gt;  <span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;              =&gt;  <span class="string">&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> a()&#123;&#125;  =&gt;  <span class="string">&quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a>2、instanceof</h3><p>语法：<code>数据 instanceof 数据类型</code>，返回 true 或 false</p>
<h4 id="（1）作用"><a href="#（1）作用" class="headerlink" title="（1）作用"></a>（1）作用</h4><ul>
<li><strong>判断一个实例是否属于某种类型；</strong></li>
<li><strong>判断一个实例是否是其父类型或者祖先类型的实例。</strong></li>
</ul>
<h4 id="（2）原理"><a href="#（2）原理" class="headerlink" title="（2）原理"></a>（2）原理</h4><p>instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败则返回**false **</p>
<h4 id="（3）实现"><a href="#（3）实现" class="headerlink" title="（3）实现"></a>（3）实现</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>             =&gt;  <span class="literal">true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>            =&gt; <span class="literal">true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>            =&gt; <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>() <span class="keyword">instanceof</span> <span class="built_in">String</span>  =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>             =&gt; <span class="literal">true</span></span><br><span class="line"><span class="keyword">function</span> b()&#123;&#125;</span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Function</span>           =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Object-prototype-toString-call"><a href="#3、Object-prototype-toString-call" class="headerlink" title="3、Object.prototype toString.call()"></a>3、Object.prototype toString.call()</h3><p>语法：<code>Object.prototype.toString.call(数据)</code>返回<code>[object 数据类型]</code></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)            =&gt;  <span class="string">&quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])            =&gt;  <span class="string">&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">function</span>()&#123;&#125;)  =&gt;  <span class="string">&quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>)            =&gt;  <span class="string">&quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)             =&gt;  <span class="string">&quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)          =&gt;  <span class="string">&quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)          =&gt;  <span class="string">&quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)     =&gt; <span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call()              =&gt; <span class="string">&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>())    =&gt;  <span class="string">&quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/at/</span>)          =&gt;  <span class="string">&quot;[object RegExp]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、类型转换"><a href="#三、类型转换" class="headerlink" title="三、类型转换"></a>三、类型转换</h2><h3 id="1、类型转换"><a href="#1、类型转换" class="headerlink" title="1、类型转换"></a>1、类型转换</h3><table>
<thead>
<tr>
<th>原始值</th>
<th align="center">转换目标</th>
<th align="right">结果</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td align="center">Boolean</td>
<td align="right">除了 0、-0、NaN 都为 true</td>
</tr>
<tr>
<td>string</td>
<td align="center">Boolean</td>
<td align="right">除了空串都为 true</td>
</tr>
<tr>
<td>undefined、null</td>
<td align="center">Boolean</td>
<td align="right">false</td>
</tr>
<tr>
<td>引用类型</td>
<td align="center">Boolean</td>
<td align="right">true</td>
</tr>
<tr>
<td>number</td>
<td align="center">string</td>
<td align="right">5=&gt;’5’</td>
</tr>
</tbody></table>
<p>| Boolean、函数<br>、symbol |string |’true’ |<br>|数组 |string |[1,2]=&gt;’1,2’ |<br>|对象 | string|’[object Object]’ |<br>|string |number |’1’=&gt;1,’a’=&gt;NaN |<br>|数组 |number |空数组=&gt;0,存在一个元素且为数字=&gt;数字,其他=&gt;NaN |<br>| null|number |0 |<br>|除了数组的引用类型 |number | NaN|<br>|symbol | number|报错 |</p>
<h3 id="2、四则运算"><a href="#2、四则运算" class="headerlink" title="2、四则运算"></a>2、四则运算</h3><ul>
<li><p>加法运算</p>
<ul>
<li>其中一方为字符串，会把另外一方也转成字符串；</li>
<li>如果一方不是字符串或数字，将它转换为数字或字符串；</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + &#x27;<span class="number">1</span>&#x27; =&gt; &#x27;<span class="number">11</span>&#x27;</span><br><span class="line">true + true =&gt; <span class="number">2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] =&gt;&#x27;<span class="number">41</span>,<span class="number">2</span>,<span class="number">3</span>&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了加法以外，只要其中一方是数字，另一方也转成数字。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ajavascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9Ajavascript/" class="post-title-link" itemprop="url">总结：javascript</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-24 21:23:10" itemprop="dateCreated datePublished" datetime="2019-10-24T21:23:10+08:00">2019-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-12 18:00:05" itemprop="dateModified" datetime="2020-03-12T18:00:05+08:00">2020-03-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、数据类型及检测"><a href="#一、数据类型及检测" class="headerlink" title="一、数据类型及检测"></a>一、数据类型及检测</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/13/JS%EF%BC%9Atypeof%E3%80%81instanceof%E4%BB%A5%E5%8F%8Aobject-prototyte-tostring-call/">参见总结：JS：typeof、instanceof 以及 Object.prototyte.toString.call()</a></p>
<h2 id="二、原型与原型链、继承"><a href="#二、原型与原型链、继承" class="headerlink" title="二、原型与原型链、继承"></a>二、原型与原型链、继承</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/15/JS%EF%BC%9A%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/">参见总结：JS：原型、原型链继承</a></p>
<h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><p>对于闭包，我的理解就是当某个函数 A 被调用时，这个函数 A 可以访问它定义时的作用域中的变量。</p>
<p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在 JavaScript 中，函数即闭包，只有函数才会产生作用域。</p>
<p>闭包有 3 个特性：</p>
<ol>
<li>函数嵌套函数；</li>
<li>在函数内部可以引用外部的参数和变量；</li>
<li>参数和变量不会以垃圾回收机制回收。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006875662">JavaScript 闭包</a></p>
<h2 id="四、浅拷贝和深拷贝"><a href="#四、浅拷贝和深拷贝" class="headerlink" title="四、浅拷贝和深拷贝"></a>四、浅拷贝和深拷贝</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2020/02/24/JS%EF%BC%9A%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">参见总结：JS：赋值、深拷贝和浅拷贝</a></p>
<h2 id="五、防抖和节流"><a href="#五、防抖和节流" class="headerlink" title="五、防抖和节流"></a>五、防抖和节流</h2><p>防抖：事件被触发 n 秒之后再执行回调，如果在这段时间之内又被触发，则重新计时。</p>
<p>节流：规定在单位时间之内只能触发一次，如果触发了多次只有一次生效。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b8de829f265da43623c4261">7 分钟理解 JS 的节流、防抖及使用场景</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c87b54ce51d455f7943dddb#chapter-three-one">2019 面试准备 - JS 防抖与节流</a></p>
<h2 id="六、数组方法、数组去重"><a href="#六、数组方法、数组去重" class="headerlink" title="六、数组方法、数组去重"></a>六、数组方法、数组去重</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/14/JS%EF%BC%9A%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">参见总结：JS：数组方法</a></p>
<p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/16/JS%EF%BC%9A%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/">参见总结：JS：数组去重</a></p>
<h2 id="七、作用域和作用域链"><a href="#七、作用域和作用域链" class="headerlink" title="七、作用域和作用域链"></a>七、作用域和作用域链</h2><p>作用域就是一个独立的地盘，让变量不会外泄、暴露出去，也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p>ES6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域</p>
<ul>
<li><strong>全局作用域</strong>：在代码中任何地方都能访问到，比如最外层函数和在最外层函数外面定义的变量、所有未定义直接赋值的变量、所有 window 对象的属性</li>
<li><strong>函数作用域</strong> ：声明在函数里面的变量 ，只在固定的代码片段内能访问到</li>
<li>**块级作用域 **：可通过 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问，所声明的变量不会提升到代码块顶部，禁止重复声明，如在一个函数内部、在一个代码块（用一对花括号包裹）内部</li>
</ul>
<p><strong>块语句（大括号“{}”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，他们不会创建一个新的作用域。</strong></p>
<p><strong>作用域在定义时就确定，并且不会改变；执行上下文在运行时确定，随时可能改变。</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c8290455188257e5d0ec64f">深入理解 JavaScript 作用域和作用域链</a></p>
<h2 id="八、this-的指向和-new-的过程"><a href="#八、this-的指向和-new-的过程" class="headerlink" title="八、this 的指向和 new 的过程"></a>八、this 的指向和 new 的过程</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/15/ES6%EF%BC%9Athis/">参见总结：ES6：this</a></p>
<h2 id="九、JavaScript-有哪些垃圾回收机制？"><a href="#九、JavaScript-有哪些垃圾回收机制？" class="headerlink" title="九、JavaScript 有哪些垃圾回收机制？"></a>九、JavaScript 有哪些垃圾回收机制？</h2><ol>
<li><p>标记清除（mark and sweep）</p>
<p>这是 JavaScript 最常见的垃圾回收方式。当变量进入执行环境的时候,比如在函数中声明一个变量，垃圾回收器将其标记为”进入环境”。当变量离开环境的时候（函数执行结束），将其标记为“离开环境”。</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量，以及被环境中变量所引用的变量（闭包）的标记。在完成这些之后仍然存在的标记就是要删除的变量。</p>
</li>
<li><p>引用计数</p>
<p>在低版本的 IE 中经常发生内存泄漏，很多时候就是因为它采用引用计数的方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数。当声明了一个变量并将一个引用类型赋值给该变量的时候，这个值的引用次数就加 1,。如果该变量的值变成另外一个，则这个值得引用次数减 1，当这个值得引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问.因此，可以将它占用的空间回收，这样垃圾回收器会在运行的时候清理引用次数为 0 的值占用的空间。</p>
<p>在 IE 中虽然 JavaScript 对象通过标记清除方式进行垃圾回收，但是 BOM 与 DOM 对象是引用计数的方式回收垃圾的。也就是说，只要涉及 BOM 和 DOM，就会出现循环引用问题。</p>
</li>
</ol>
<h2 id="十、列举几种类型的-DOM-节点"><a href="#十、列举几种类型的-DOM-节点" class="headerlink" title="十、列举几种类型的 DOM 节点"></a>十、列举几种类型的 DOM 节点</h2><ul>
<li>整个文档是一个文档（Document）节点</li>
<li>每个 HTML 标签是一个元素（Element）节点</li>
<li>每一个 HTML 属性是一个属性（Attribute）节点</li>
<li>包含在 HTML 元素中的文本是文本（Text）节点</li>
</ul>
<h2 id="十一、谈谈-script-标签中-defer-和-async-属性的区别"><a href="#十一、谈谈-script-标签中-defer-和-async-属性的区别" class="headerlink" title="十一、谈谈 script 标签中 defer 和 async 属性的区别"></a>十一、谈谈 script 标签中 defer 和 async 属性的区别</h2><ol>
<li>defer 属性规定是否延迟执行脚本，直到页面加载为止。async 属性规定脚本一旦可用，就异步执行；</li>
<li>defer 并行加载 JavaScript 文件，会按照页面上 script 标签的顺序执行。async 并行加载 JavaScript 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行。</li>
</ol>
<h2 id="十二、encodeURI-和-decodeURI-的作用是什么？"><a href="#十二、encodeURI-和-decodeURI-的作用是什么？" class="headerlink" title="十二、encodeURI()和 decodeURI()的作用是什么？"></a>十二、encodeURI()和 decodeURI()的作用是什么？</h2><p>encodeURI()用于将 URL 转换为十六进制编码，而 decodeURI()用于将编码的 URL 转换成正常的 URL。</p>
<h2 id="十三、为什么不建议在-JavaScript-中使用-innerHTML？"><a href="#十三、为什么不建议在-JavaScript-中使用-innerHTML？" class="headerlink" title="十三、为什么不建议在 JavaScript 中使用 innerHTML？"></a>十三、为什么不建议在 JavaScript 中使用 innerHTML？</h2><p>通过 innerHTML 修改内容，每次都会刷新，因此很慢。在 innerHTML 中没有验证的机会，因此更容易在文档中插入错误代码，使网页不稳定。</p>
<h2 id="十四、在-DOM-操作中怎样创建、添加、移除、替换、插入和查找节点？"><a href="#十四、在-DOM-操作中怎样创建、添加、移除、替换、插入和查找节点？" class="headerlink" title="十四、在 DOM 操作中怎样创建、添加、移除、替换、插入和查找节点？"></a>十四、在 DOM 操作中怎样创建、添加、移除、替换、插入和查找节点？</h2><ol>
<li>创建节点</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">createDocumentFragment</span><span class="params">()</span></span> <span class="comment">// 创建一个DOM片段</span></span><br><span class="line"><span class="function"><span class="title">createElement</span><span class="params">()</span></span>  <span class="comment">//创建一个具体的元素</span></span><br><span class="line"><span class="function"><span class="title">createTextNode</span><span class="params">()</span></span>  <span class="comment">//创建一个文本节点</span></span><br></pre></td></tr></table></figure>

<p>2.添加、移除、替换、插入节点</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">appendChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">removeChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">replaceChild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">insertBefore</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查找节点</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getElementByTagName</span><span class="params">()</span></span>  <span class="comment">//通过标签名称查找节点</span></span><br><span class="line"><span class="function"><span class="title">getElementByName</span><span class="params">()</span></span>  <span class="comment">//通过元素的name属性查找节点（IE容错能力较强，会得到一个数组，其中包括id等于name值得节点）</span></span><br><span class="line"><span class="function"><span class="title">getElementById</span><span class="params">()</span></span>  <span class="comment">//通过元素Id查找节点，具有唯一值</span></span><br></pre></td></tr></table></figure>

<h2 id="十五、null-和-undefined-的区别是什么？"><a href="#十五、null-和-undefined-的区别是什么？" class="headerlink" title="十五、null 和 undefined 的区别是什么？"></a>十五、null 和 undefined 的区别是什么？</h2><p>null 是一个表示“无”的对象，转为数值时为 0；undefined 是一个表示“无”的原始值，转为数值时为 NaN。</p>
<p>当声明的变量还未初始化时，变量的默认值为 undefined。</p>
<p>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p>
<p>undefined 表示“缺少值”，即此处应该有一个值，但是还没有定义，典型用法是：</p>
<ol>
<li>如果变量声明了，但是没有赋值，它就等于 undefined；</li>
<li>当调用函数时，如果没有提供应该提供的参数，该参数就等于 undefined；</li>
<li>如果对象没有赋值，该属性的值为 undefined；</li>
<li>当函数没有返回值时，默认返回 undefined。</li>
</ol>
<p>null 表示“没有对象”，即此处不应该有值，典型用法是：</p>
<ol>
<li>作为函数的参数，表示该函数的参数不是对象；</li>
<li>作为对象原型链的终点。</li>
</ol>
<h2 id="十六、JavaScript-延迟加载的方式有哪些？"><a href="#十六、JavaScript-延迟加载的方式有哪些？" class="headerlink" title="十六、JavaScript 延迟加载的方式有哪些？"></a>十六、JavaScript 延迟加载的方式有哪些？</h2><p>包括 defer 和 async，动态创建 DOM（创建 script，插入 DOM 中，加载完毕后回调，按需异步载入 JavaScript）。</p>
<h2 id="十七、call、apply、bind"><a href="#十七、call、apply、bind" class="headerlink" title="十七、call、apply、bind"></a>十七、call、apply、bind</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/15/JS%EF%BC%9Acall%E3%80%81apply%E3%80%81bind/">参见总结：JS：call、apply、bind</a></p>
<h2 id="十八、哪些操作会造成内存泄漏？"><a href="#十八、哪些操作会造成内存泄漏？" class="headerlink" title="十八、哪些操作会造成内存泄漏？"></a>十八、哪些操作会造成内存泄漏？</h2><p>内存泄漏指不再拥有或需要任何对象（数据）之后，它们仍然存在于内存中。</p>
<p><strong>提示：</strong> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的唯一引用是循环的，那么该对象占用的内存立即被回收。</p>
<p>如果 settimeout 的第一个参数使用字符串而非函数，会引发内存泄漏。</p>
<p>闭包、控制台日志，循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）等会造成内存泄漏。</p>
<h2 id="十九、列举-IE-与-Firefox-的不同之处。"><a href="#十九、列举-IE-与-Firefox-的不同之处。" class="headerlink" title="十九、列举 IE 与 Firefox 的不同之处。"></a>十九、列举 IE 与 Firefox 的不同之处。</h2><p>不同之处如下。</p>
<ol>
<li>IE 支持 currentStyle，Firefox 使用 getComputStyle；</li>
<li>IE 使用 innerText，Firefox 使用 textContent;</li>
<li>在透明度过滤镜方面，IE 使用 filter:alpha(opacity = num); Firefox 使用-moz-opacity:num；</li>
<li>在事件方面，IE 使用 attachEvent；Firefox 使用 addEventListener；</li>
<li>对于鼠标位置：IE 使用 event.clientX；Firefox 使用 event.pageX；</li>
<li>IE 使用 event.srcElement；Firefox 使用 event.target。</li>
<li>要消除 list 圆点，IE 中仅需使 margin：0 即可达到最终效果，Firefox 中需要设置 margin：0，padding：0，list-style：none；</li>
<li>css 圆角：IE7 以下不支持圆角。</li>
</ol>
<h2 id="二十、如何实现异步编程？"><a href="#二十、如何实现异步编程？" class="headerlink" title="二十、如何实现异步编程？"></a>二十、如何实现异步编程？</h2><ol>
<li>通过回调函数，优点是简单、容易理解和部署；缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程混乱，而且每个任务只能指定一个回调函数。</li>
<li>通过事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化；缺点是整个程序都要变成事件驱动型，运行流程会变得恨不清晰。</li>
<li>采用发布/订阅方式，性质与“事件监听”类似，但是明显优于后者；</li>
<li>通过 Promise 对象实现，Promise 对象是 CommonJS 工作组提出的一种规范，旨在为异步编程提供统一接口。它的思想是，每一个异步任务返回一个 Promise 对象，该对象有一个 then 方法，允许指定回调函数。</li>
</ol>
<h2 id="二十一、请解释一下-JavaScript-的同源策略。"><a href="#二十一、请解释一下-JavaScript-的同源策略。" class="headerlink" title="二十一、请解释一下 JavaScript 的同源策略。"></a>二十一、请解释一下 JavaScript 的同源策略。</h2><p>同源策略是客户端脚本（尤其是 JavaScript）的重要安全度量标准。它最早出自 Netscape Navigator 2.0，目的是防止某个文档或脚本从多个不同源装载。</p>
<p>这里的同源策略指的是协议、域名、端口相同。同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h2 id="二十二、为什么要有同源限制？"><a href="#二十二、为什么要有同源限制？" class="headerlink" title="二十二、为什么要有同源限制？"></a>二十二、为什么要有同源限制？</h2><p>我们举例说明，比如一个黑客，他利用 Iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名、密码登录时，他的页面就可以通过 JavaScript 读取到你表单上 input 的内容，这样黑客就会轻松得到你的用户名和密码。</p>
<h2 id="二十三、map-filter-和-reduce"><a href="#二十三、map-filter-和-reduce" class="headerlink" title="二十三、map,filter 和 reduce"></a>二十三、map,filter 和 reduce</h2><p><a href="">参见总结：JS：map、filter、reduce</a></p>
<h2 id="二十四、前端模块化"><a href="#二十四、前端模块化" class="headerlink" title="二十四、前端模块化"></a>二十四、前端模块化</h2><p><a href="https://chajianyuan.github.io/2019/10/20/JS%EF%BC%9A%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">参见总结：JS：前端模块化</a></p>
<h2 id="二十五、数组方法"><a href="#二十五、数组方法" class="headerlink" title="二十五、数组方法"></a>二十五、数组方法</h2><p><a href="">参见总结：JS：数组方法</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chajianyuan.github.io/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chajianyuan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="查见原的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/24/%E6%80%BB%E7%BB%93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8/" class="post-title-link" itemprop="url">总结：浏览器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-24 21:31:05" itemprop="dateCreated datePublished" datetime="2019-10-24T21:31:05+08:00">2019-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-28 16:47:52" itemprop="dateModified" datetime="2020-02-28T16:47:52+08:00">2020-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <meta name="referrer" content="no-referrer"/>

<h2 id="一、一个-URL-从输入到显示的过程"><a href="#一、一个-URL-从输入到显示的过程" class="headerlink" title="一、一个 URL 从输入到显示的过程"></a>一、一个 URL 从输入到显示的过程</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2020/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%B8%80%E4%B8%AAURL%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/">参见总结：浏览器：一个 URL 从输入到显示的过程</a></p>
<h2 id="二、重绘和回流"><a href="#二、重绘和回流" class="headerlink" title="二、重绘和回流"></a>二、重绘和回流</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/">参见总结：浏览器：重绘和回流</a></p>
<h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5cb33660e51d456e811d2687">JavaScript 中的垃圾回收和内存泄漏</a></p>
<h2 id="四、浏览器兼容性"><a href="#四、浏览器兼容性" class="headerlink" title="四、浏览器兼容性"></a>四、浏览器兼容性</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/59a3f2fe6fb9a0249471cbb4">浏览器兼容问题</a></p>
<h2 id="五、浏览器缓存机制"><a href="#五、浏览器缓存机制" class="headerlink" title="五、浏览器缓存机制"></a>五、浏览器缓存机制</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">参见总结：浏览器：浏览器缓存机制</a></p>
<h2 id="六、事件机制"><a href="#六、事件机制" class="headerlink" title="六、事件机制"></a>六、事件机制</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/19/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">参见总结：浏览器：事件机制</a></p>
<h2 id="七、事件循环机制"><a href="#七、事件循环机制" class="headerlink" title="七、事件循环机制"></a>七、事件循环机制</h2><p><a target="_blank" rel="noopener" href="https://cjy1.github.io/2019/10/18/%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEeventloop/">参见总结：浏览器：事件循环 Eventloop</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chajianyuan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chajianyuan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
